% \iffalse meta-comment
%
% Copyright Â© 2021 by Timothy S. Jones
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Timothy S. Jones.
%
% This work consists of the files tikz-dna.dtx and tikz-dna.ins
% and the derived file tikz-dna.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{tikz-dna.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[2005/12/01]
%<package>\ProvidesPackage{tikz-dna}
%<*package>
    [2021/06/05 v0.0.1 DNA diagrams using TikZ]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{hypdoc}
\usepackage{tikz-dna}[2021/06/05]
\usepackage{xspace}
\def\tikzname{Ti\emph{k}Z\xspace}
\def\eg{e\@.g\@.\xspace}
\def\mybreak{\\[\baselineskip]}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{tikz-dna.dtx}
\PrintChanges
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.0.1}{2021/06/05}{Initial version}
%
% \GetFileInfo{tikz-dna.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment,\RequirePackage}
% \DoNotIndex{\let,\def,\edef,\gdef,\xdef,\noexpand,\relax,\empty}
% \DoNotIndex{\expandafter,\if,\else,\fi,\ifnum,\ifx,\global,\long,\@gobble}
% \DoNotIndex{\g@addto@macro,\@ifnextchar,\@ifundefined,\@nameuse}
% \DoNotIndex{\@firstoftwo,\@secondoftwo,\@percentchar,\@tempa}
% \DoNotIndex{\begin,\end,\begingroup,\endgroup}
% \DoNotIndex{\csname,\endcsname,\foreach,\breakforeach}
% \DoNotIndex{\space,\string,\uppercase,\show}
% \DoNotIndex{\node,\draw,\path,\p,\x,\y,\tikzset,\pgfutil@empty}
% \DoNotIndex{\zslope,\strut}
% \DoNotIndex{\PackageError,\PackageWarning}
% \DoNotIndex{\a,\b,\c,\chara,\charb,\charc,\csname,\meaning,\message}
%
% \title{The \textsf{tikz-dna} package\thanks{This document corresponds to \textsf{tikz-dna}~\fileversion, dated \filedate.}}
% \author{Timothy S. Jones \\ \texttt{tsj@empty.sh}}
%
% \maketitle
%
% \tableofcontents
%
% \section{Introduction}
%
% Put text here.
%
% \begin{tikzpicture}
%   \dna [] at (0,0) {[]HLHL};
% \end{tikzpicture}
%
% \StopEventually{}
%
% \section{Implementation}
%
% The parsing sequence (with some recursion) goes roughly like:
%
% \begin{verbatim}
% \dna
% \tikz@dna
% \tikz@dna@
% \tikz@dna@at
% \tikz@dna@@@
% \tikz@dna@@@init
% \tikzdna@parser
% \tikzdna@testfornum
% \tikzdna@testfornum@
% \tikzdna@testfornum@@
% \tikzdna@testfornum@@@
% \tikzdna@testfornum@@@@
% \tikzdna@testforcode
% \tikzdna@parser@
% \end{verbatim}
%
% \subsection{Required packages}
%
%    \begin{macrocode}
\RequirePackage{tikz}
\usetikzlibrary{calc}
\RequirePackage{unravel}
\unravelsetup{max-action=500,max-input=500,max-output=500}
%    \end{macrocode}
%
% \subsection{Top-level handlers}
%
% \begin{macro}{\textdna}
%   Creates an inline diagram. This macro only parses its optional argument
%   to check if it is a initial character or \tikzname keys and then calls
%   \cs{dna} appropriately.
%   \mybreak Usage: \cs{textdna} \oarg{initial character or TikZ keys} \marg{sequence characters}
%    \begin{macrocode}
\DeclareRobustCommand*\textdna[2][]{%
  \begingroup
  \let\tikzdna@lastchar\empty
  \let\tikzdna@settings\empty
  \tikzset{dna/before/.append style={dna/before text}}%
  \tikzset{dna/after/.prefix style={dna/after text}}%
  \ifx\relax#1\relax\else
  \tikzdna@testoptarg#1\relax\relax%
  \fi
  \begin{tikzpicture}[dna/intext,baseline={(0,0)}]
    \tikzdna@picinit
    \def\@tempa{\expandafter\dna\expandafter[\tikzdna@settings] at (0,0)}%
    \expandafter\@tempa\expandafter{\expandafter[\tikzdna@lastchar]#2};%
  \end{tikzpicture}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testoptarg}
%    \begin{macrocode}
\def\tikzdna@testoptarg#1#2\relax{%
  \ifx\relax#2\relax
  \uppercase{\def\tikzdna@lastchar{#1}}%
  \else
  \def\tikzdna@settings{#1#2}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@picinit}
%   For things which should only by initialized once per |tikzpicture|.
%    \begin{macrocode}
\def\tikzdna@picinit{%
  \global\let\tikzdna@namednodes\empty
}
\let\tikzdna@namednodes\empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@installcommands}
%   Add \cs{dna} to the \tikzname internal |\tikz@installcommands| macro.
%   The |\dna| macro will be installed at the beginning of the |tikzpicture|.
%    \begin{macrocode}
\g@addto@macro\tikz@installcommands{%
  \let\tikz@origdna=\dna%
  \let\dna=\tikz@dna%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@uninstallcommands}
%   Add \cs{dna} to the \tikzname internal |\tikz@uninstallcommands| macro.
%   The |\dna| macro will be uninstalled at the beginnings of nodes.
%    \begin{macrocode}
\g@addto@macro\tikz@uninstallcommands{%
  \let\dna=\tikz@origdna%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@dna}
%   Proxy to \cs{tikz@dna@} that passes an empty options list |[]| if options
%   were omitted, as in |\dna at (0,0) {...};|.
%    \begin{macrocode}
\def\tikz@dna{%
  \@ifnextchar{[}%
  {\tikz@dna@}%
  {\tikz@dna@[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@dna@}
%   Usage: \cs{tikz@dna@} \oarg{optional TikZ keys}
%    \begin{macrocode}
\def\tikz@dna@[#1]{%
  \tikz@dna@at{#1}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\tikz@dna@at}
%   A proxy to \cs{tikz@dna@@@}. The second argument is in anticipation of a space between |at| and the coordinate.
%   \mybreak Usage: \cs{tikz@dna@at} \meta{optional TikZ keys} |at| \meta{anything} \parg{coordinate}
%    \begin{macrocode}
\def\tikz@dna@at#1at#2(#3){%
  \tikz@dna@@@{#1}{#2(#3)}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@dna@@@}
%^^A FIXME missing documentation
%   Usage: \cs{tikz@dna@@@} \meta{optional TikZ keys} \meta{coordinate} \meta{sequence characters}
%    \begin{macrocode}
\def\tikz@dna@@@#1#2#3{%
  \begingroup
  \tikzdna@init
  \let\tikz@alias=\pgfutil@empty%
  \begin{scope}[shift={#2},dna,#1]%
%    \end{macrocode}
% Check if the sequence characters are preceeded by an initial character, \eg |[P]P|.
% Pass an empty list if |[]| if no initial character is present.
%    \begin{macrocode}
    % \unravel{
    \@ifnextchar{[}%
    {\tikz@dna@@@init}%
    {\tikz@dna@@@init[]}%
    #3\relax
    % }
    \tikzset{dna/before}%
    \tikzdna@str;%
    \path let \p1 = (dna/end top), \p2 = (dna/end base),
    \p3 = (dna/end), \p4 = (dna/start) in
    [/utils/exec={%
      \xdef\tikzdna@northeast{\noexpand%
        \pgfpoint{.5*\pgf@pt@aa*\x1}{.5*\pgf@pt@bb*\y1}}%
      \xdef\tikzdna@startpoint{\noexpand%
        \pgfpoint{\pgf@pt@aa*(\x4-.5*\x1)}{\pgf@pt@bb*(\y4-.5*\y1)}}%
      \xdef\tikzdna@endpoint{\noexpand%
        \pgfpoint{\pgf@pt@aa*(\x3-.5*\x1)}{\pgf@pt@bb*(\y3-.5*\y1)}}%
    }];
    \node [shape=tikzdna@shape,anchor=origin,#1] at (0,0) {};
    \tikzset{dna/after}%
  \end{scope}%
  \endgroup
  \tikz@dna@@@end
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@init}
%   General definitions before drawing.
%    \begin{macrocode}
\def\tikzdna@init{%
  \def\tikzdna@lastchar{@}%
  \def\tikzdna@num{0}%
  \let\tikzdna@currentchar\empty
  \let\tikzdna@settings\empty
  \let\tikzdna@fromchar\empty
  \let\tikzdna@tochar\empty
  \let\setwscale\tikzdnasetwscale
  \def\wscale{\tikzdna@wscale}%
  \let\xunit\tikzdna@xunit
  \let\yunit\tikzdna@yunit
  \def\slope{\dnaslope}%
  \def\lslope{\dnaslope}%
  \def\zslope{\dnazslope}%
  \def\dslope{\dnadslope}%
  \gdef\tikzdna@saved@settings{}%
  \gdef\tikzdna@saved@options{}%
  \gdef\tikzdna@oldnodecenter@{}%
  \def\tikzdnawidth{0.0}%
  \setcounter{tikzdnatrans}{-1}%
  \setcounter{tikzdnatranspos}{0}%
  \tikzdna@initstr{%
    \useasboundingbox (0,0) rectangle (\tikzdnawidth,\dnaheight);
    \draw [dna/every char] (0,0)
    coordinate (dna@refa)
    coordinate (dna@ref)  at (0,\dnaheight/2)
    coordinate (dna@refb) at (0,\dnaheight)
    coordinate (dna/start)
    coordinate (dna/start base)
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@dna@@@end}
%   Gobble trailing |;| or print error if absent.
%    \begin{macrocode}
\def\tikz@dna@@@end{%
  \@ifnextchar{;}%
  {\@gobble}%
  {\PackageError{tikz-package}{Can not parse dna path}{}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikz@dna@@@init}
%   Opens a group which will end in \cs{tikzdna@parser@end}. Begins the process
%   of parsing an initial character, \eg |[P]P|, and finally triggers the parsing
%   of the sequence characters.
%^^A BUG this is probably not needed for tikz-dna. There will be no initial position.
%   \mybreak Usage: \cs{tikz@dna@@@init} \oarg{initial character}
%    \begin{macrocode}
\def\tikz@dna@@@init[#1]{%
  \begingroup
%    \end{macrocode}
% If |#1| is empty or |\relax|, do nothing. Otherwise, make |#1| uppercase and save the
% result in |\tikzdna@lastchar|.\footnote{See \TeX{}book exercise 7\@.8 for usage
% of \cs{uppercase}.}
%    \begin{macrocode}
  \ifx\relax#1\relax\else
  \uppercase{\def\tikzdna@lastchar{#1}}%
  \fi
%    \end{macrocode}
% If |\cs{tikzdna@initcode@\tikzdna@lastchar}|, \eg |\tikzdna@initcode@U|,
% is defined then expand it. This handles the initial character. Note that
% |\tikzdna@initcode@| is |@|.
%    \begin{macrocode}
  \@ifundefined{tikzdna@initcode@\tikzdna@lastchar}%
  {}%
  {\@nameuse{tikzdna@initcode@\tikzdna@lastchar}}%
%    \end{macrocode}
% If \cs{tikzdna@lastchar} is |@|, then |\relax|. Otherwise, 
%    \begin{macrocode}
  \if @\tikzdna@lastchar\relax\else
  \tikzdna@iftrans{@\tikzdna@lastchar}%
  {\tikzdna@nameaddtostr{@}{\tikzdna@lastchar}{}}%
  {\PackageWarning{tikz-dna}{Start value for sequence character
      '\tikzdna@lastchar' is not defined and will be ignored!}{}{}{}}%
  \fi
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Parser}
%
% \begin{macro}{\tikzdna@parser}
%   Top-level handler for parsing a sequence specification. If the next character
%   is \cs{relax}, begin conclusion, otherwise begin parsing chain, checking
%   for numbers, control characters, and code before a standard sequence character.
%   Note that \cs{@ifnextchar} sets \cs{@let@token} which used elsewhere.\footnote{See
%   |source2e| for the definition of \cs{@ifnextchar}.}
%    \begin{macrocode}
\def\tikzdna@parser{%
  \@ifnextchar\relax
  {\tikzdna@parser@end}%
  {\tikzdna@testfornum}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@parser@end}
%    \begin{macrocode}
\def\tikzdna@parser@end{%
  \def\tikzdna@output@nextchar{@}%
  \let\tikzdna@fromchar\tikzdna@tochar
  \edef\tikzdna@tochar{@}%
  \tikzdna@output@flush
  \global\let\tikzdnawidth\tikzdnawidth
  \tikzdna@addtostr{ coordinate (dna/end)
    let \p1 = (dna/start base), \p2 = (dna/end), \p3 = (0,1) in
    coordinate (dna/end base) at (\x2,\y1)
    coordinate (dna/end top)  at (\x2,\y1+\y3)
  }%
  \endgroup
  \tikzdna@endhook%
}
\let\tikzdna@endhook\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@parser@}[1]{Next Character}
%^^A KLUDGE
%   Not a control character, not a number, not code. This is the juicy part. Unravel to 1693.
%    \begin{macrocode}
\def\tikzdna@parser@#1{%
%    \end{macrocode}
% Stop if there ar no more characters.
%    \begin{macrocode}
  \ifx\relax#1\empty
  \expandafter\tikzdna@parser@end
%    \end{macrocode}
% Otherwise, pick the first or second argument based on whether |#1| is an alphabetic character.
%    \begin{macrocode}
  \else
  \tikzdna@iflower{#1}%
  {\tikzdna@setnum{\tikzdna@num/2}}%
  {}%
  \ifx\tikzdna@back\empty\else
  \tikzdna@setnum{\tikzdna@num - \tikzdna@back}%
  \global\let\tikzdna@back\empty
  \fi
%    \end{macrocode}
%^^A KLUDGE
% Current position?
%    \begin{macrocode}
  \pgfmathparse{\tikzdnawidth + \tikzdna@num}%
  \global\let\tikzdnawidth\pgfmathresult
  \uppercase{\gdef\tikzdna@currentchar{#1}}%
%    \end{macrocode}
%^^A KLUDGE
% Special case transitions, e.g. H->L? \cs{tikzdna@lastchar} will generally be |@|.
%    \begin{macrocode}
  \@nameuse{tikzdna@beforenextcode@\tikzdna@lastchar}%
%    \end{macrocode}
%^^A KLUDGE
% Things to be executed before this sequence character. No such control sequences
% are defined in this document. Unravel 1704.
%    \begin{macrocode}
  \@nameuse{tikzdna@beforecode@\tikzdna@currentchar}%
  \tikzdna@output{\tikzdna@lastchar}{\tikzdna@currentchar}%
%    \end{macrocode}
%^^A KLUDGE
% Unravel 1744.
%    \begin{macrocode}
  \global\let\tikzdna@lastchar\tikzdna@currentchar
%    \end{macrocode}
% Things to be executed after this sequence character.
%    \begin{macrocode}
  \@nameuse{tikzdna@aftercode@\tikzdna@currentchar}%
%    \end{macrocode}
% Save lowercased \cs{tikzdna@currentchar} as \cs{@tempa}.
%    \begin{macrocode}
  \expandafter\lowercase\expandafter{%
    \expandafter\def\expandafter\@tempa
    \expandafter{\tikzdna@currentchar}%
  }%
%    \end{macrocode}
%^^A KLUDGE
% What is |@cmd|?
%    \begin{macrocode}
  \pgfkeysifdefined{/tikz/dna/\@tempa/text/.@cmd}%
  {\expandafter\expandafter\expandafter\tikzdna@testfortext}%
%    \end{macrocode}
% Parse next character.
%    \begin{macrocode}
  {\expandafter\expandafter\expandafter\tikzdna@parser}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Text}
%
% \begin{macro}{\tikzdna@testfortext}
%    \begin{macrocode}
\def\tikzdna@testfortext{%
  \@ifnextchar\bgroup
  {\tikzdna@handletext}%
  {\tikzdna@parser}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@handletext}[1]{Text}
%   Looks ahead if the current character is the last one and sets the end-of-line
%   marker if so.
%
%   This seems outdated because |handletext@| does not flush the output any more.
%    \begin{macrocode}
\def\tikzdna@handletext#1{%
  \@ifnextchar\relax
  {\def\tikzdna@output@nextchar{@}\tikzdna@handletext@{#1}}%
  {\def\tikzdna@output@nextchar{Z}\tikzdna@handletext@{#1}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@handletext@}[1]{Text}
%    \begin{macrocode}
\def\tikzdna@handletext@#1{%
  \@ifnextchar{[}%
  {\tikzdna@handletext@@}%
  {\tikzdna@handletext@@[]}%
  #1\tikzdna@endoftext
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@handletext@@}[2]{Optional Settings}{Text}
%    \begin{macrocode}
\def\tikzdna@handletext@@[#1]#2\tikzdna@endoftext{%
  \@ifnextchar{\relax}%
  {\def\tikzdna@output@nextchar{@}%
    \tikzdna@handletext@@@{#1}{#2}}%
  {\tikzdna@handletext@@@{#1}{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@handletext@@@}[2]{Optional Settings}
%   {Text}
%    \begin{macrocode}
\def\tikzdna@handletext@@@#1#2{%
  \expandafter\lowercase\expandafter{%
    \expandafter\def\expandafter\@tempa
    \expandafter{\tikzdna@currentchar}%
  }%
  \edef\@tempa{node [dna/\@tempa/text,}%
  \expandafter\tikzdna@output@addcode\expandafter{%
    \@tempa
    #1] at ($ (dna@dstart) !.5! (dna@dend) $)
    {\tikzdna@textformat{#2}}
  }%
  \ifcase0%
  \if @\tikzdna@output@bufchara
  1%
  \else
  \ifx\tikzdna@output@bufchara\tikzdna@currentchar
  1%
  \fi
  \fi
  \relax
  \else
  \fi
  \xdef\tikzdna@output@bufcharb{\tikzdna@currentchar @edge@}%
  \xdef\tikzdna@lastchar{\tikzdna@currentchar @edge@}%
  \tikzdna@parser
}
\let\tikzdna@textformat\empty
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Numbers}
%
% \begin{macro}{\tikzdna@testfornum}
%   Begin parsing a number.
%    \begin{macrocode}
\def\tikzdna@testfornum{%
  \global\let\tikzdna@num\tikzdna@wscale
  \let\tikzdna@numchars\empty
  \tikzdna@numfrac0\relax
  \afterassignment
  \tikzdna@testfornum@
  \tikzdna@numint0%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testfornumfrac}
%    \begin{macrocode}
\def\tikzdna@testfornumfrac{%
  \afterassignment
  \tikzdna@testfornum@@@
  \tikzdna@numfrac1%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testfornum@}
%   The \cs{@let@token} set in \cs{tikzdna@parser} is used to handle |0|
%   which cannot be detected using the \cs{tikzdna@numint} value.
%    \begin{macrocode}
\def\tikzdna@testfornum@{%
  \ifx0\@let@token
  \let\tikzdna@next\tikzdna@testfornum@@
  \else
  \ifnum0<\tikzdna@numint
  \let\tikzdna@next\tikzdna@testfornum@@
  \else
  \def\tikzdna@next{%
    \@ifnextchar{.}%
    {\expandafter\tikzdna@testfornumfrac\@gobble}%
    {%
      \tikzdna@numint1\relax
      \tikzdna@numfrac0\relax
      \global\let\tikzdna@num\tikzdna@wscale
      \if@tikzdna@metachar
      {\def\@tempa{\expandafter\expandafter\expandafter
          \tikzdna@parser
          \csname tikzdna@metachar@\meaning\@let@token\endcsname{1}}%
        \expandafter\@tempa\@gobble
      }%
      {\tikzdna@testforcode}%
    }%
  }%
  \fi\fi
  \tikzdna@next
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testfornum@@}
%    \begin{macrocode}
\def\tikzdna@testfornum@@{%
  \@ifnextchar{.}%
  {\expandafter\tikzdna@testfornumfrac\@gobble}%
  {\tikzdna@testfornum@@@}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testfornum@@@}
%    \begin{macrocode}
\def\tikzdna@testfornum@@@{%
  \edef\tikzdna@num{\the\tikzdna@numint.\expandafter\@gobble\the\tikzdna@numfrac}%
  \tikzdna@setnum{\tikzdna@wscale * \tikzdna@num}%
  \@ifnextchar\bgroup
  {%
    \expandafter\tikzdna@numfrac\expandafter0\expandafter
    \@gobble\the\tikzdna@numfrac\relax
    \ifnum0=\tikzdna@numfrac\else
    \pgfmathparse{round(\tikzdna@num)}%
    \PackageWarning{tikz-dna}%
    {Can not repeat group by a non-integer factor!^^J%
      Rounding '\tikzdna@num' to '\pgfmathresult'.}{}{}{}%
    \global\let\tikzdna@num\pgfmathresult
    \fi
    \tikzdna@testfornum@@@@
  }%
  {%
    \if@tikzdna@metachar
    {\def\@tempa{\expandafter\expandafter\expandafter
        \tikzdna@parser
        \csname tikzdna@metachar@\meaning\@let@token\expandafter\endcsname
        \expandafter{\tikzdna@num}}%
      \expandafter\@tempa\@gobble
    }%
    {\tikzdna@testforcode}%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testfornum@@@@}[1]{Characters and other tokens to
%   repeat}
%    \begin{macrocode}
\def\tikzdna@testfornum@@@@#1{%
  \begingroup
  \@temptokena{#1}%
  \tikzdna@numloop%
  \endgroup
  \tikzdna@numint1\relax
  \tikzdna@numfrac0\relax
  \expandafter\tikzdna@parser\tikzdna@numchars
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@numloop}
%    \begin{macrocode}
\def\tikzdna@numloop{%
  \ifnum\tikzdna@numint>0%
  \toks@\expandafter{\tikzdna@numchars}%
  \xdef\tikzdna@numchars{%
    \the\toks@
    \the\@temptokena
  }%
  \advance\tikzdna@numint by -1\relax
  \expandafter\tikzdna@numloop
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Code (`!' modifier)}
%
% \begin{macro}{\tikzdna@testforcode}
%    \begin{macrocode}
\def\tikzdna@testforcode{%
  \@ifnextchar{!}%
  {\tikzdna@testforcode@}%
  {\@ifundefined{tikzdna@code@\meaning\@let@token}%
    {\tikzdna@parser@}%
%    \end{macrocode}
% Get the next token and then expand \cs{tikzdna@code@}\meta{next token}
%    \begin{macrocode}
    {\expandafter\afterassignment
      \csname tikzdna@code@\meaning\@let@token\endcsname
      \let\@let@token=%
    }%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@testforcode@}[1]{Character to gobble}
%    \begin{macrocode}
\def\tikzdna@testforcode@#1{%
  \@ifnextchar\bgroup
  {\tikzdna@handlecode}%
  {%
    \PackageWarning{tikz-dna}{Missing braces after '!' character. Ignoring
      this character}{}{}{}%
    \tikzdna@parser
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@handlecode}[1]{Code to add to string}
%    \begin{macrocode}
\def\tikzdna@handlecode#1{%
  \tikzdna@output@addcode{ #1 }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{General definitions}
%
%    \begin{macrocode}
\def\tikzdnawidth{0.0}
\newcount\tikzdna@numint
\newcount\tikzdna@numfrac
\def\tikzdna@wscale{1.0}%
\def\tikzdnasetwscale#1{%
  \pgfmathparse{#1}%
  \let\tikzdna@wscale\pgfmathresult
}
\def\tikzdna@num{0.0}%
\let\tikzdna@back\empty
\newlength\tikzdna@xunit
\newlength\tikzdna@yunit
\def\tikzdna@@xunit{1.6ex}%
\def\tikzdna@@yunit{1.6ex}%
\setlength{\tikzdna@xunit}{\tikzdna@@xunit}%
\setlength{\tikzdna@yunit}{\tikzdna@@yunit}%

\def\tikzdna@setnum#1{%
  \pgfmathparse{#1}%
  \global\let\tikzdna@num\pgfmathresult
}

\newcount\tikzdna@debug

\def\tikzdna@xsep{0pt}
\def\tikzdna@ysep{0pt}

\newcounter{tikzdna@nrows}%
\def\tikzdna@rowdist{2}%
\def\tikzdna@coldist{1}%

\def\tikzdna@prefix{tikzdna@trans@}%
\def\tikzdna@ttt#1#2#3{#1#2#3}%
\def\tikzdna@pfxtr{%
  \tikzdna@prefix\expandafter\tikzdna@ttt
}

\def\dnawidth{1}%
\def\dnaheight{1}%
%    \end{macrocode}
%
% \subsection{\tikzname styles}
%    \begin{macrocode}
\tikzset{%
  dna/.style={/tikz,
    line cap=round, line join=round,
    dna/adjust@xy,
    every path/.append code={\tikz@expandcount=\tikzdna@expandcount\relax},
  },%
}
\tikzset{%
  dna/.cd,
  adjust@xy/.style={%
    /utils/exec={%
      \tikz@textfont
      \let\@tempa\fsize
      \let\fsize\@tempdima
      \fsize=\f@size pt\relax
      \pgfmathsetlength{\tikzdna@xunit}{\tikzdna@@xunit}%
      \pgfmathsetlength{\tikzdna@yunit}{\tikzdna@@yunit}%
      \let\fsize\@tempa
    },%
    /tikz/x=\tikzdna@xunit, /tikz/y=\tikzdna@yunit,
  },
  expand count/.store in={\tikzdna@expandcount},
  expand count=1000,
  unit/.style={%
    /utils/exec={%
      \def\tikzdna@@xunit{#1}%
      \let\tikzdna@@yunit\tikzdna@@xunit
    },%
    /tikz/dna/adjust@xy,%
  },
  xunit/.style={%
    /utils/exec={%
      \def\tikzdna@@xunit{#1}%
    },%
    /tikz/dna/adjust@xy,%
  },
  yunit/.style={%
    /utils/exec={%
      \def\tikzdna@@yunit{#1}%
    },%
    /tikz/dna/adjust@xy,%
  },
  font/.style={%
    /tikz/font={#1},
    /tikz/dna/adjust@xy
  },%
  initchar/.value required,
  initchar/.code={\uppercase{\gdef\tikzdna@lastchar{#1}}},
  metachar/.code={\tikzdnametachar#1},
  grid/.style={dna,help lines},
  @grid/.code={\textdnagrid},
  draw grid/.style={%
    dna/before text/.append style={dna/@grid},%
    dna/before/.append style={dna/@grid}%
  },
  no grid/.style={dna/@grid/.code={}},
  before/.code={},
  after/.code={},
  before text/.code={\textdnabefore},
  after text/.code={\textdnaafter},
  picture/.style={dna,line width=0.15ex},
  intext/.style={dna,line width=0.15ex},
  inline node/.style={shape=coordinate},
  inline node/from char/.store in=\tikzdna@node@fromchar,
  inline node/to char/.store in=\tikzdna@node@tochar,
  table/.style={font=\sffamily,dna,line width=0.15ex},
  before table/.code={},
  after table/.code={},
  coord/.style={coordinate},
  save/.style={coordinate},
  restore/.style={/utils/exec={\expandafter\tikzset\expandafter{\tikzdna@saved@options}}},
  option/.style={/utils/exec={\g@addto@macro\tikzdna@saved@options{#1,}},#1},
  nooptions/.style={/utils/exec={\gdef\tikzdna@saved@options{}}},
  popoptions/.style={/utils/exec={\tikzdna@popoptions}},
  pushoptions/.style={/utils/exec={\tikzdna@pushoptions}},
  name/.style={inner sep=0pt,outer sep=0pt,minimum size=0pt},
  text format/.store in=\tikzdna@textformat,
  @/.style={},
  every char/.style={},
  every bg/.style={},
  D/.style={dna/d},
  D/text/.style={dna/d/text},
  D/background/.style={dna/d/background},
  D@edge@/.style={dna/d@edge@},
  D@edge@/text/.style={dna/d@edge@/text},
  D@edge@/background/.style={dna/d@edge@/background},
  U/.style={dna/u},
  U/text/.style={dna/u/text},
  U/background/.style={dna/u/background},
  U@edge@/.style={dna/u@edge@},
  U@edge@/text/.style={dna/u@edge@/text},
  U@edge@/background/.style={dna/u@edge@/background},
  H/.style={dna/h},
  L/.style={dna/l},
  E/.style={dna/e},
  E/background/.style={dna/e/background},
  M/decoration/.style={dna/m/decoration},
  M/base/.style={dna/m/base},
  M/.style={dna/m},
  G/.style={dna/g},
  Z/.style={dna/z},
  T/.style={dna/t},
  C/.style={dna/c},
  X/.style={dna/x},
  d/.style={},
  d/text/.style={dna,scale=0.6,font=\sffamily},
  d/background/.style={draw=none},
  d@edge@/.style={dna/d},
  d@edge@/text/.style={dna/d/text},
  d@edge@/background/.style={dna/d/background},
  u/.style={},
  u/background/.style={draw=none,fill=gray},
  u@edge@/.style={dna/u},
  u@edge@/text/.style={dna/u/text},
  u@edge@/background/.style={dna/u/background},
  h/.style={},
  l/.style={},
  e/.style={},
  e/background/.style={draw=none},
  m/decoration/.style={decorate,%
    decoration={zigzag,segment length=.25\tikzdna@xunit,
      amplitude=.225\tikzdna@yunit}},
  m/base/.style={black!40!brown},
  m/.style={dna/m/base,dna/m/decoration},
  g/.style={decorate=false},
  z/.style={blue},
  t/.style={},
  c/.style={dna/lslope=0.0},
  x/.style={red},
  table/grid/.style={dna/grid},
  table/lines/.style={},
  table/rules/.style={line width=0.08em,line cap=butt},
  table/midrules/.style={line width=0.05em,line cap=butt},
  table/header/.style={dna/name},
  table/label header/.style={},
  table/row header/.style={},
  slope/.code={%
    \tikzdnasetslope{#1}%
    \tikzdnasetdslope{2*#1}%
    \tikzdnasetzslope{#1/2}%
  },
  lslope/.code={\tikzdnasetslope{#1}},
  dslope/.code={\tikzdnasetdslope{#1}},
  zslope/.code={\tikzdnasetzslope{#1}},
  wscale/.code={\tikzdnasetwscale{#1}},
  coldist/.store in=\tikzdna@coldist,
  rowdist/.store in=\tikzdna@rowdist,
  outer xsep/.store in=\tikzdna@xsep,
  outer ysep/.store in=\tikzdna@ysep,
  outer sep/.style={/tikz/dna/outer xsep=#1,/tikz/dna/outer ysep=#1},
  debug/level/.code={\tikzdna@debug=#1\relax},
  debug/level/.value required,
  debug/scope/.style={font=\sffamily\tiny,gray},
  debug/node/.style={above,inner sep=2pt},
  debug/nodes/.style={%
    /tikz/dna/after table/.append code={\tikzdna@marknodes{\tikzdna@namednodes}},
    /tikz/dna/after text/.append code={\tikzdna@marknodes{\tikzdna@namednodes}}
  },
  debug/markcmd/.store in={\tikzdna@markcmd},
}
\tikzset{dna/inline node/.cd,
  from char={}, to char={}
}
%    \end{macrocode}
%
% \subsection{Text-mode macros}
% \begin{macro}{\textdnabefore}
%   This macro is executed inside the |tikzpicture| environment of \cs{textdna}
%   before the dna diagram is drawn.
%    \begin{macrocode}
\def\textdnabefore{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\textdnaafter}
%   This macro is executed inside the |tikzpicture| environment of \cs{textdna}
%   after the dna diagram is drawn.
%    \begin{macrocode}
\def\textdnaafter{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\textdnagrid}
%   Draws a background grid with the "dna/grid" setting. Should be used inside
%   \cs{textdnabefore}.
%    \begin{macrocode}
\def\textdnagrid{%
  \draw[xstep={\dnawidth/2.},ystep={\dnaheight/2.},dna/grid] (0,0) grid
  (\dnawidth*\tikzdnawidth,\dnaheight);
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Internal macros}
%
% \begin{macro}{\tikzdna@trans@}
%    \begin{macrocode}
\def\tikzdna@trans@#1#2#3#4{%
  \unexpanded\expandafter\expandafter\expandafter{%
    \csname\tikzdna@prefix #2#3#4\endcsname{#1}{#2}{#3}{#4}
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@beforenextcode@D@edge@}
%    \begin{macrocode}
\def\tikzdna@beforenextcode@D@edge@{%
  \if D\tikzdna@currentchar\else
  \gdef\tikzdna@lastchar{D}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@beforenextcode@U@edge@}
%    \begin{macrocode}
\def\tikzdna@beforenextcode@U@edge@{%
  \if U\tikzdna@currentchar\else
  \gdef\tikzdna@lastchar{U}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@initcode@}
%   If empty init char was given, exchange it with "@".
%    \begin{macrocode}
\def\tikzdna@initcode@{%
  \gdef\tikzdna@lastchar{@}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@initcode@D}
%    \begin{macrocode}
\def\tikzdna@initcode@D{%
  \gdef\tikzdna@lastchar{D@edge@}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@initcode@U}
%    \begin{macrocode}
\def\tikzdna@initcode@U{%
  \gdef\tikzdna@lastchar{U@edge@}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Add-to-macro macros}
% \begin{macro}{\tikzdna@eaddto}[2]{Macro name}{Tokens to add to macro}
%    \begin{macrocode}
\def\tikzdna@eaddto#1#2{%
  \begingroup
  \tikzdna@internaldefs
  \@temptokena\expandafter{#1}%
  \xdef#1{%
    \the\@temptokena
    #2%
  }%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\iftrue
%    \end{macrocode}
%
% \begin{macro}{\tikzdna@initstr}
%    \begin{macrocode}
\long\def\tikzdna@initstr{%
  \def\tikzdna@str
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@eaddtostr}
%    \begin{macrocode}
\def\tikzdna@eaddtostr{%
  \tikzdna@eaddto\tikzdna@str
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addtostr}
%    \begin{macrocode}
\def\tikzdna@addtostr{%
  \g@addto@macro\tikzdna@str
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\else
%    \end{macrocode}
%
% \begin{macro}{\tikzdna@str}
%    \begin{macrocode}
\def\tikzdna@file{\jobname.ttg}
\newwrite\tikzdna@fh
\def\tikzdna@str{%
  \tikzdna@addtostr{;}%
  \immediate\closeout\tikzdna@fh
  \begingroup
  \makeatletter
  \@@input\tikzdna@file\relax
  \endgroup
  \@ifnextchar;{\@gobble}{}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@initstr}
%    \begin{macrocode}
\long\def\tikzdna@initstr{%
  \immediate\openout\tikzdna@fh= \tikzdna@file\relax
  \tikzdna@addtostr
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@eaddtostr}
%    \begin{macrocode}
\long\def\tikzdna@eaddtostr#1{%
  \begingroup
  \tikzdna@internaldefs
  \let\par\empty
  \immediate\write\tikzdna@fh{#1}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addtostr}
%    \begin{macrocode}
\long\def\tikzdna@addtostr#1{%
  \begingroup
  \tikzdna@internaldefs
  \let\par\empty
  \immediate\write\tikzdna@fh{\unexpanded{#1}}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
% \begin{macro}{\tikzdna@makeglobal}
%    \begin{macrocode}
\def\tikzdna@makeglobal#1{%
  \global\let#1#1\relax\relax
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@iftrans}
%   Usage: \cs{tikzdna@iftrans} \meta{characters}
%    \begin{macrocode}
\def\tikzdna@trans{}%
\def\tikzdna@iftrans#1{%
  \tikzdna@iftrans@#1\empty\empty\empty\relax
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@iftrans}
%   Usage: \cs{tikzdna@iftrans} \meta{first character} \meta{second character} \meta{next character} \meta{eats token til end marker}
%    \begin{macrocode}
\def\tikzdna@iftrans@#1#2#3#4\relax{%
  \begingroup
  \xdef\tikzdna@trans{#1#2}%
  \ifx\tikzdna@trans\empty
  \gdef\tikzdna@trans{{@}{}{@}}%
  \else
  \global\let\tikzdna@trans\relax
  % Use triple macros before double macros
  \@ifundefined{tikzdna@triple@#2}%
  {\@ifundefined{\tikzdna@prefix#1#2}%
    {}%
    {\xdef\tikzdna@trans{{#1}{#2}{}}}%
  }%
  {%
    \@ifundefined{\tikzdna@prefix#1#2#3}%
    {}%
    {\xdef\tikzdna@trans{{#1}{#2}{#3}}}%
  }%
  % If both do not exist, search for aliases:
  \ifx\tikzdna@trans\relax
  \@ifundefined{tikzdna@alias@#1}%
  {\edef\chara{{#1}}}%
  {\edef\chara{{#1},{\csname tikzdna@alias@#1\endcsname}}}%
  \@ifundefined{tikzdna@alias@#2}%
  {\edef\charb{{#2}}}%
  {\edef\charb{{#2},{\csname tikzdna@alias@#2\endcsname}}}%
  \@ifundefined{tikzdna@triple@#2}%
  {\def\charc{\empty}}%
  {%
    \@ifundefined{tikzdna@alias@#3}%
    {\edef\charc{{#3},}}%
    {\edef\charc{{#3},{\csname tikzdna@alias@#3\endcsname},}}%
  }%
  \ifx\charb\empty
  \def\charb{\empty}%
  \fi
  \let\tikzdna@next\relax
  \foreach \b in \charb {%
    \foreach \a in \chara {%
      \foreach \c in \charc {%
        % \message{ ^^J Testing: \a\b\c ^^J}%
        \@ifundefined{\tikzdna@prefix\a\b\c}%
        {}{%
          \xdef\tikzdna@trans{{#1}{#2}{#3}}%
          \expandafter\tikzdnacpy\expandafter
          {\tikzdna@trans}{\a\b\c}%
          \ifnum\tikzdna@debug>0
          \message{^^J DEBUG: '#1#2#3' = '\a\b\c' ^^J}%
          \fi
          \expandafter\tikzdna@makeglobal
          \csname\tikzdna@pfxtr\tikzdna@trans\endcsname
          \ifnum\tikzdna@debug>1
          \ifnum\tikzdna@debug>2
          \expandafter\show\csname\tikzdna@pfxtr\tikzdna@trans\endcsname
          \else
          \message{^^J\tikzdna@trans:
            \expandafter\meaning\csname\tikzdna@pfxtr\tikzdna@trans\endcsname^^J}%
          \message{^^J\a\b\c:
            \expandafter\meaning\csname\tikzdna@prefix\a\b\c\endcsname^^J}%
          \fi
          \fi
          \global\let\tikzdna@next\breakforeach
        }%
        \tikzdna@next
      }%
      \tikzdna@next
    }%
    \tikzdna@next
  }%
  \fi
  \fi
  \endgroup
  \ifx\tikzdna@trans\relax
  \expandafter\@secondoftwo
  \else
  \expandafter\@firstoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@nameaddtostr}
%   {First character}{Second character}
%   {Optional next character}
%    \begin{macrocode}
\def\tikzdna@nameaddtostr#1#2#3{%
  \tikzdna@iftrans{{#1}{#2}{#3}}%
  {%
    % \edef\@tempa{\noexpand\tikzdna@trans@{\tikzdna@num}\tikzdna@trans}%
    % \expandafter\tikzdna@addtostr
    % \expandafter{\@tempa}%
    \edef\@tempa{\noexpand\tikzdna@trans@{\tikzdna@num}\tikzdna@trans}%
    % \tikzdna@eaddtostr{\@percentchar\space {#1}{#2}{#3}}%
    \tikzdna@eaddtostr{\@tempa}%
    % \tikzdna@eaddtostr{\tikzdna@trans@{\tikzdna@num}\tikzdna@trans}%
  }%
  {\PackageWarning{tikz-dna}{No transitions '#1#2' (or '#1#2#3') defined!}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@addcode}
%   Adds code to the output code buffer. The code will not be expanded, i.e.\ will
%   be protected from the expansion when the buffer is flushed.
%    \begin{macrocode}
\def\tikzdna@output@addcode#1{%
  \g@addto@macro\tikzdna@output@bufcode{\unexpanded{ #1 }}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@eaddcode}
%   Adds code to the output code buffer. The code will be expanded when the buffer
%   is flushed.
%    \begin{macrocode}
\def\tikzdna@output@eaddcode#1{%
  \g@addto@macro\tikzdna@output@bufcode{ #1 }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@Eaddcode}
%   Adds code to the output code buffer. The code will be expanded immediately and
%   again when the buffer is flushed.
%    \begin{macrocode}
\def\tikzdna@output@Eaddcode{%
  \tikzdna@eaddto\tikzdna@output@bufcode%
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Output routine}
%
% Initialize buffer macros.
%    \begin{macrocode}
\def\tikzdna@output@bufchara{}%
\def\tikzdna@output@bufcharb{}%
\def\tikzdna@output@bufnum{0}%
\def\tikzdna@output@bufcode{}%
\def\tikzdna@output@nextchar{}%
%    \end{macrocode}
%
% \begin{macro}{\tikzdna@output}
%^^A KLUDGE
%   Usage: \cs{tikzdna@output} \meta{previous character} \meta{current character}
%    \begin{macrocode}
\def\tikzdna@output#1#2{%
  \edef\tikzdna@fromchar{#1}%
  \edef\tikzdna@tochar{#2}%
  \ifx\relax#2\relax
  % \tikzdna@output@codeflush
  \tikzdna@nameaddtostr{}{#1}{}%
  \else
  \ifcase0%
  \ifx\tikzdna@output@bufchara\empty
  \ifx\tikzdna@output@bufcharb\empty
  1%
  \fi
  \fi\relax
  % not empty
  \edef\tikzdna@output@currentchar{#2}%
  \ifcase0%
  \ifx\tikzdna@output@bufcode\empty% Stop combining if code was inserted
  \expandafter\ifx\csname tikzdna@nocombine@#2\endcsname\relax
  \ifx\tikzdna@output@currentchar\tikzdna@output@bufcharb
  2%
  \fi
  \fi
  \else
  1%
  \fi
  \relax
  \edef\tikzdna@output@nextchar{#2}%
  \tikzdna@output@flush
  \xdef\tikzdna@output@bufchara{#1}%
  \xdef\tikzdna@output@bufcharb{#2}%
  \or
  \edef\tikzdna@output@nextchar{#2}%
  \tikzdna@output@flush
  \xdef\tikzdna@output@bufchara{#1}%
  \xdef\tikzdna@output@bufcharb{#2}%
  \or
  \pgfmathparse{\tikzdna@output@bufnum + \tikzdna@num}%
  \global\let\tikzdna@output@bufnum\pgfmathresult
  \fi
  \else % empty
  \tikzdna@output@codeflush
  \xdef\tikzdna@output@bufchara{#1}%
  \xdef\tikzdna@output@bufcharb{#2}%
  \global\let\tikzdna@output@bufnum\tikzdna@num
  \fi
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@flush}
%    \begin{macrocode}
\def\tikzdna@output@flush{%
  \tikzdna@output@charflush
  \tikzdna@output@codeflush
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@codeflush}
%    \begin{macrocode}
\def\tikzdna@output@codeflush{%
  \ifx\tikzdna@output@bufcode\empty\else
  \tikzdna@eaddtostr{\tikzdna@output@bufcode}%
  \global\let\tikzdna@output@bufcode\empty%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@output@charflush}
%   A group is used to protect the current value of |num| which is the length of
%   the new character after the flushed old character. This value will be assigned
%   to the new buffer length |bufnum|.
%    \begin{macrocode}
\def\tikzdna@output@charflush{%
  \begingroup
  \let\tikzdna@num\tikzdna@output@bufnum
  \tikzdna@nameaddtostr
  {\tikzdna@output@bufchara}%
  {\tikzdna@output@bufcharb}%
  {\tikzdna@output@nextchar}%
  \endgroup%
  \gdef\tikzdna@output@nextchar{}%
  \gdef\tikzdna@output@bufchara{}%
  \gdef\tikzdna@output@bufcharb{}%
  \global\let\tikzdna@output@bufnum\tikzdna@num
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Macros for character definitions}
%
% \begin{macro}{\tikzdna@nameedef}[4]{Macro name to be defined (without
%   prefix)}{Content of macro}
%   Defines internal tikzdna macro with name |\|\meta{prefix}\meta{name (\#2)}.
%   The macro definition (\#3) is expanded while the internal drawing definitions
%   are active.
%    \begin{macrocode}
\newcommand\tikzdna@nameedef[4]{%
  \def\@gtempa##1{#4}%
  \begingroup
  \tikzdna@internaldefs
  \xdef\@gtempa##1##2##3##4{\@gtempa{\width}}%
  \endgroup
  \expandafter\let\csname\tikzdna@prefix#1#2#3\endcsname\@gtempa
  \let\@gtempa\empty
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@namelet}[2]{Original Characters}{New Characters}
%   Only execute |\let| if the original macro is defined or the destination macro
%   is defined and would now set to undefined.
%    \begin{macrocode}
\newcommand\tikzdna@namelet[2]{%
  \ifcase0%
  \@ifundefined{\tikzdna@prefix#2}%
  {\@ifundefined{\tikzdna@prefix#1}%
    {0}{1}%
  }%
  {1}%
  \relax
  \else
  \expandafter\let
  \csname\tikzdna@prefix#1\expandafter\endcsname
  \csname\tikzdna@prefix#2\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Definition of modifiers}
%
% \begin{macro}{\tikzdna@defcode}
%   Defines\footnote{See |source2e| for the definition of \cs{@namedef}.} a
%   macro to handle a control character. |\meaning|\footnote{See chapter 20
%   in the \TeX{}book for the meaning of \cs{meaning}.} is used to produce
%   a valid control sequence name in the case of a special character.
%   \mybreak Usage \cs{tikzdna@defcode} \meta{control character}
%    \begin{macrocode}
\def\tikzdna@defcode#1{%
  \@namedef{tikzdna@code@\meaning#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{@}}
%   Simply executes given code. The |\relax| is added to have some protection
%   against user code manipulating the parser macro. The "@" character can be both
%   a letter (in style files) and a character (in user documents), so it is
%   defined twice.
%    \begin{macrocode}
\tikzdna@defcode{@}#1{%
  #1\relax
  \tikzdna@parser
}
\begingroup
\expandafter\let\expandafter\temp
\csname tikzdna@code@\meaning @\endcsname
\makeatother
\expandafter\global\expandafter\let
\csname tikzdna@code@\meaning @\endcsname\temp
\endgroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{DOLLAR}}
%   Takes the code between two dollar signs and parses it as math expression. The
%   result is put back on the input stream. This allows the calculation of
%   character width.
%    \begin{macrocode}
\tikzdna@defcode$#1${%
  \pgfmathparse{#1}%
  \expandafter
  \tikzdna@parser\pgfmathresult
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{,}}
%    \begin{macrocode}
\tikzdna@defcode{,}{%
  \tikzdna@output@eaddcode{%
    \newdraw [dna/every char]
  }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{;}}
%    \begin{macrocode}
\tikzdna@defcode{;}{%
  \endgroup\begingroup
  \tikzdna@output@eaddcode{%
    \newdrawns [dna/every char]
  }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{N}}
%    \begin{macrocode}
\tikzdna@defcode{N}{%
  \@ifnextchar[%]
  {\tikzdna@addnode@getoptions}%
  {\tikzdna@addnode@getoptions[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{n}}
%    \begin{macrocode}
\tikzdna@defcode{n}{%
  \@ifnextchar[%]
  {\tikzdna@addnode@getoptions}%
  {\tikzdna@addnode@getoptions[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{B}}
%    \begin{macrocode}
\tikzdna@defcode{B}{%
  \pgfmathparse{\tikzdna@back+\tikzdna@num}%
  \global\let\tikzdna@back\pgfmathresult
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{b}}
%    \begin{macrocode}
\tikzdna@defcode{b}{%
  \pgfmathparse{\tikzdna@back+\tikzdna@num/2}%
  \global\let\tikzdna@back\pgfmathresult
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{F}}
%    \begin{macrocode}
\tikzdna@defcode{F}{%
  \pgfmathparse{\tikzdna@back-\tikzdna@num}%
  \global\let\tikzdna@back\pgfmathresult
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode{f}}
%    \begin{macrocode}
\tikzdna@defcode{f}{%
  \pgfmathparse{\tikzdna@back-\tikzdna@num/2}%
  \global\let\tikzdna@back\pgfmathresult
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode []}[1]{Options}
%   Single brackets are in-picture options.
%   Brackets and a "!" sign "[! !]" are parser options.
%   Double brackets are both.
%
%   Brackets and "| |" signs "[| |]" are only-once in-picture options.
%    \begin{macrocode}
\tikzdna@defcode[{%}]{
  \@ifnextchar[%]
  {\tikzdna@bothoption}%
  {\@ifnextchar{!}%
    {\tikzdna@parseroption}%
    {\@ifnextchar{|}%
      {\tikzdna@onceoption}%
      {\tikzdna@addoption}%
    }%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@parseroption}[1]{Options}
%   Sets the given options immediately, so that they are in affect for the rest of
%   the parser run.
%    \begin{macrocode}
\def\tikzdna@parseroption!#1!]{%
  \pgfqkeys{/tikz/dna}{#1}%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addoption}[1]{Options}
%   Adds the options to the internal list of dna options.
%    \begin{macrocode}
\def\tikzdna@addoption#1]{%
  \tikzdna@output@addcode{ [dna/option={#1}] }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@bothoption}[1]{Options}
%   Does executes and adds the options to the output code buffer. This is
%   necessary for slopes if they are used in width calculations.
%    \begin{macrocode}
\def\tikzdna@bothoption[#1]]{%
  \tikzset{#1}%[
  \tikzdna@addoption{#1}]%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@onceoption}[1]{Options}
%   Simply adds the options to the output code buffer.
%    \begin{macrocode}
\def\tikzdna@onceoption|#1|]{%
  \tikzdna@output@addcode{ [#1] }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Local scopes, push/pop options}
%
% \begin{macro}{\tikzdna@defcode bgroup}
%    \begin{macrocode}
\tikzdna@defcode{\bgroup}{%
  \tikzdna@output@eaddcode{%
    [dna/pushoptions]
    \newdraw [dna/every char]
  }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@defcode egroup}
%    \begin{macrocode}
\tikzdna@defcode{\egroup}{%
  \tikzdna@output@eaddcode{%
    [dna/popoptions]
    \newdraw [dna/every char]
  }%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@popoptions}
%    \begin{macrocode}
\def\tikzdna@popoptions{%
  \expandafter\tikzdna@popoptions@\tikzdna@optionstack\relax
}
\def\tikzdna@optionstack{{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@popoptions@}
%    \begin{macrocode}
\def\tikzdna@popoptions@#1#2\relax{%
  \gdef\tikzdna@saved@options{#1}%
  \gdef\tikzdna@optionstack{#2}%
  \ifx\tikzdna@optionstack\empty
  \gdef\tikzdna@optionstack{{}}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\tikzdna@pushoptions}
%    \begin{macrocode}
\def\tikzdna@pushoptions{%
  \expandafter\expandafter\expandafter\gdef
  \expandafter\expandafter\expandafter\tikzdna@optionstack
  \expandafter\expandafter\expandafter{%
    \expandafter\expandafter\expandafter{\expandafter\tikzdna@saved@options\expandafter}\tikzdna@optionstack}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Add-Node Macros}
%
% \begin{macro}{\tikzdna@addnode}[1]{Options}
%    \begin{macrocode}
\def\tikzdna@addnode@getoptions[#1]{%
  \@ifnextchar(%)
  {\tikzdna@addnode@getname{#1}}%
  {\tikzdna@addnode@getname{#1}()}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addnode@getname}[2]{Previous read options}{Node name}
%    \begin{macrocode}
\def\tikzdna@addnode@getname#1(#2){%
  \@ifnextchar\bgroup
  {\tikzdna@addnode@{#1}{#2}}%
  {\tikzdna@addnode@{#1}{#2}{}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addnode@}[3]{Options}{Node name}{Node text}
%   The |fromchar| and |tochar| macros are to be expanded in the output routine,
%   not inside this macro. They do not hold the correct values yet.
%    \begin{macrocode}
\def\tikzdna@addnode@#1#2#3{%
  \def\@tempa{#2}%
  \ifx\@tempa\empty
  \def\@tempa{ node [dna/inline node,%
    dna/inline node/from char={\tikzdna@fromchar},%
    dna/inline node/to char={\tikzdna@tochar},%
    \unexpanded{#1}] }%
  \def\@tempb{}%
  \else
  \def\@tempa{ node [dna/inline node,%
    dna/inline node/from char={\tikzdna@fromchar},%
    dna/inline node/to char={\tikzdna@tochar},%
    \unexpanded{#1}] (\unexpanded{#2}) }%
  \xdef\tikzdna@namednodes{\tikzdna@namednodes,#2}%
  \fi
  \expandafter\tikzdna@output@eaddcode\expandafter{\@tempa \unexpanded{{#3}}}%
  \tikzdna@parser
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@marknodes}[1]{Comma-separated list of node names}
%    \begin{macrocode}
\newcommand*\tikzdna@marknodes[2][]{%
  \scope[dna/debug/scope,#1]
  \edef\@tempa{floor((\noexpand\y1-\tikzdna@xunit) / \tikzdna@rowdist\tikzdna@xunit) * \tikzdna@rowdist\tikzdna@xunit}%
  \foreach \N in #2 {%
    \ifx\N\empty\else
    \tikzdna@markcmd
    \path let \p1=(\N) in
    node [dna/debug/node] at ($ (\x1,\noexpand\@tempa) + (0,1) $) {\N};
    \fi
  }%
  \endscope
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@markcmd}
%    \begin{macrocode}
\def\tikzdna@markcmd{ \draw (\N) circle (1pt); }%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@mark@nodes}[1]{Comma-separated list of node names}
%    \begin{macrocode}
\newcommand*\tikzdna@mark@nodes[2][]{%
  \begingroup
  \def\@tempa{#2}%
  \ifx\@tempa\empty \let\@tempa\tikzdna@namednodes \fi
  \ifx\@tempa\space \let\@tempa\tikzdna@namednodes \fi
  \def\@tempb{\tikzdna@marknodes[#1]}%
  \expandafter\@tempb\expandafter{\expandafter{\@tempa}}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Meta-characters}
%
% \begin{macro}{\tikzdnametachar}[1]{Meta-character}
%   Checks if there is an optional argument and calls \cs{tikzdna@metachar}
%   appropriately.
%    \begin{macrocode}
\def\tikzdnametachar#1{%
  \@ifnextchar{[}%]
  {\tikzdna@metachar{#1}}%
  {\tikzdna@metachar{#1}[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@metachar}[3]{Macro character}{Number of
%   Arguments}{Substituted Characters}
%    \begin{macrocode}
\def\tikzdna@metachar#1[#2]#3{%
  \ifx\relax#3\relax
  \expandafter\let\csname tikzdna@metachar@\meaning#1\endcsname\@undefined
  \else
  \@namedef{tikzdna@metachar@\meaning#1}{}%
  \ifx\relax#2\relax
  \expandafter\renewcommand\expandafter*%
  \csname tikzdna@metachar@\meaning#1\expandafter
  \endcsname\expandafter[1]{##1{#3}}%
  \else
  \expandafter\renewcommand\expandafter*%
  \csname tikzdna@metachar@\meaning#1\expandafter
  \endcsname\expandafter[#2]{#3}%
  \fi
  \fi
  \ifnum\tikzdna@debug=-1
  \message{^^J Defined meta-char '#1' as:
    \expandafter\meaning\csname tikzdna@metachar@\meaning#1\endcsname ^^J}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\if@tikzdna@metachar}[2]{True clause}{False clause}
%   Only works in an argument of |\@ifnextchar|. This macro sets the needed
%   |\@let@token| macro.
%    \begin{macrocode}
\def\if@tikzdna@metachar#1#2{%
  \@ifundefined{tikzdna@metachar@\meaning\@let@token}{#2}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Table environment}
%    \begin{macrocode}
%      \usetikzlibrary{backgrounds}
\newcounter{tikzdnarows}
%    \end{macrocode}
%
% \begin{environment}{tikzdnatable}[1]{Optional settings}
%    \begin{macrocode}
\def\abc{\tracingassigns=1}
\newenvironment{tikzdnatable}[1][]{%
  \begingroup
  \setcounter{tikzdna@nrows}{0}%
  \def\tikzdna@maxwidth{0.0}%
  \let\extracode\tikzdna@extracode
  \let\endextracode\tikzdna@endextracode
  \let\tablegrid\tikzdna@tablegrid
  \let\fulltablegrid\tikzdna@fulltablegrid
  \let\horlines\tikzdna@horlines
  \let\vertlines\tikzdna@vertlines
  \let\marknodes\tikzdna@mark@nodes
  \def\background{\pgfonlayer{background}\scope}%
  \def\endbackground{\endscope\endpgfonlayer}%
  \def\tablerules{\tikzdna@tablerules}%
  \def\tableheader{\tikzdna@tableheader}%
  \def\rowdist{\tikzdna@rowdist}%
  \def\coldist{\tikzdna@coldist}%
  \def\nrows{\the\c@tikzdna@nrows}%
  \def\twidth{\tikzdna@maxwidth}%
  \tikzpicture[dna/table,#1]%
  \coordinate (@last row)  at (0,\rowdist);
  \coordinate (label@header)   at ($ -1*(\tikzdna@coldist,0) + 1.5*(0,\tikzdna@rowdist) $);
  \coordinate (diagram@header) at ($                              1.5*(0,\tikzdna@rowdist) $);
  \coordinate (dna@table@bottom right) at (0,0);
  \coordinate (dna@table@bottom left)  at ($ -1*(\tikzdna@coldist,0) $);
  \tikzdna@picinit
  \tikzset{dna/before table}%
  \tikzdnatable@checkrow
}{%
  \tikzset{dna/after table}%
  \endtikzpicture
  \endgroup
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\tikzdna@extracode}
%   Set "all rows" rectangle node using the auxiliary coordinates.
%    \begin{macrocode}
\def\tikzdna@extracode{%
  \path
  let
  \p1 = (row1.north west),
  \p2 = (dna@table@bottom right),
  \p3 = (\x2-\x1,\y1-\y2),
  \p4 = (\pgf@pt@aa * \x3, \pgf@pt@bb * \y3)
  in
  node [shape=rectangle,anchor=north west,
  minimum width=\x4,minimum height=\y4,
  inner sep=0pt,outer sep=0pt]
  at (\x1,\y1) (all rows) {}
  ;
  \path
  let
  \p0 = ($ -1*(\tikzdna@coldist,0) + (0,1) $),
  \p1 = (label1.north east),
  \p2 = (dna@table@bottom left),
  \p3 = (\x0-\x2,\y1-\y2),
  \p4 = (\pgf@pt@aa * \x3, \pgf@pt@bb * \y3)
  in
  node [shape=rectangle,anchor=north east,
  minimum width=\x4,minimum height=\y4,
  inner sep=0pt,outer sep=0pt]
  at (\x1,\y1) (all labels) {}
  ;
  \@ifnextchar[{\tikzdna@oset}{}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@endextracode}
%   Now empty because \cs{tikzdnatable@chkendec} handles the
%   continuation of the row scanning process.
%    \begin{macrocode}
\def\tikzdna@endextracode{%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@checkrow}
%   Checks the next token to be either \cs{end}, \cs{extracode} or
%   \cs{begin}. In the case of the latter \cs{tikzdnatable@chkbegec}
%   is called to test if it is \cs{begin}|{extracode}|.
%    \begin{macrocode}
\def\tikzdnatable@checkrow{%
  \@ifnextchar\end
{\tikzdnatable@chkendec}%
{\ifx\@let@token\extracode
  \let\tikzdna@next\empty
  \else
  \ifx\@let@token\begin
    \def\tikzdna@next{\tikzdnatable@chkbegec}%
    \else
    \def\tikzdna@next{\tikzdnatable@row}%
    \fi
    \fi
    \tikzdna@next
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@chkbegec}
%   Checks if value of \cs{begin} is |{extracode}|. If so
%   it is executed, otherwise it is taken as normal row and so
%   \cs{tikzdnatable@row} is called.
%    \begin{macrocode}
\def\tikzdnatable@chkbegec\begin#1{
    \begingroup
    \def\@tempa{#1}%
    \def\@tempb{extracode}%
    \ifx\@tempa\@tempb
    \endgroup
    \def\tikzdna@next{\begin{extracode}}%
      \else
      \endgroup
      \def\tikzdna@next{\tikzdnatable@row\begin{#1}}%
        \fi
        \tikzdna@next
      }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@chkendec}
%   Checks if value of \cs{end} is |{extracode}|. If so
%   it is executed, otherwise it is taken as normal row and so
%   \cs{tikzdnatable@row} is called.
%    \begin{macrocode}
\def\tikzdnatable@chkendec\end#1{
\begingroup
\def\@tempa{#1}%
\def\@tempb{extracode}%
\ifx\@tempa\@tempb
\endgroup
\def\tikzdna@next{\end{extracode}\tikzdnatable@row}%
\else
\endgroup
\def\tikzdna@next{\end{#1}}%
\fi
\tikzdna@next
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@oset}
%   [1]{TikZ Keys}
%   Handle optional TikZ settings. The \cs{tikz@options} must be used
%   to ensure that the settings apply for the following graphic paths.
%    \begin{macrocode}
\def\tikzdna@oset[#1]{%
  \let\tikz@options\pgfutil@empty
  \tikzset{#1}%
  \tikz@options
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@emptycell}
%   Just used as marker. Needs unique definition.
%    \begin{macrocode}
\def\tikzdna@emptycell{%
  \@gobble{tikzdna@emptycell}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@row}[1]{Row content}
%    \begin{macrocode}
\long\def\tikzdnatable@row#1\\{%
  \tikzdnatable@row@#1&\tikzdna@emptycell&\\
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@row@}[3]{Cell 1}{Cell 2 or empty}{Potential
%   further cells}
%    \begin{macrocode}
\long\def\tikzdnatable@row@#1&#2&#3\\{%
  \ifx\\#3\\\else
  \begingroup
  \def\@tempa{\tikzdna@emptycell&}%
  \def\@tempb{#3}%
  \ifx\@tempa\@tempb\else
  \PackageWarning{tikz-dna}{%
    To many columns in tikzdnatable row! Only two are allowed%
  }{}{}{}%
  \fi
  \endgroup
  \fi
  \ifx\tikzdna@emptycell#2%
  \def\tikzdna@next{\tikzdnatable@row@@{#1}{}}%
  \else
  \def\tikzdna@next{\tikzdnatable@row@@{#1}{#2}}%
  \fi
  \tikzdna@next
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnatable@row@@}[2]{Name/Label}{Timing characters}
%    \begin{macrocode}
\long\def\tikzdnatable@row@@#1#2{%
  \addtocounter{tikzdna@nrows}{1}%
  \coordinate (@last row) at ($ (@last row) - (0,\tikzdna@rowdist) $);
  \node [anchor=base east,dna/name,alias=last label] (label\the\c@tikzdna@nrows)
  at ($ (@last row) - (\tikzdna@coldist,0) $) {\ignorespaces #1\unskip\strut};
  \path let \p1 = (dna@table@bottom left), \p2 = (last label.south west) in
  coordinate (dna@table@bottom left) at ({min(\x1,\x2)},\y2);
  %
  \@ifnextchar{[}%
  {\tikzdna@tabledna}%
  {\tikzdna@tabledna[]}%
  #2\relax
  \path let \p1 = (dna@table@bottom right), \p2 = (dna/end base) in
  coordinate (dna@table@bottom right) at ({max(\x1,\x2)},\y2);
  %
  \pgfmathparse{max(\tikzdna@maxwidth,\tikzdnawidth)}%
  \let\tikzdna@maxwidth\pgfmathresult
  \tikzdnatable@checkrow
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\tikzdna@tabledna}
%    \begin{macrocode}
\def\tikzdna@tabledna[#1]#2\relax{%
  \let\tikzdna@lastchar\empty
  \let\tikzdna@settings\empty
  \ifx\relax#1\relax\else
  \tikzdna@testoptarg#1\relax\relax
  \fi
  \ifx\tikzdna@lastchar\empty
  \def\tikzdna@lastchar{@}%
  \fi
  \edef\@tempa{\noexpand\dna
    [name=row\the\c@tikzdna@nrows,alias=last row,%
    \expandafter\unexpanded\expandafter{\tikzdna@settings}] at (@last row)}%
  \expandafter\@tempa\expandafter{\expandafter[\tikzdna@lastchar]#2};
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\tikzdna@fulltablegrid}[1]{Optional settings}
%    \begin{macrocode}
\newcommand*\tikzdna@fulltablegrid[1][]{%
  \begin{pgfonlayer}{background}
    \scope[xstep={\dnawidth/2.},ystep={\dnaheight/2.},
    shift={(all rows.south west)},dna/table/grid,#1]
    \draw (0,0) grid ($ (all rows.north east) - (all rows.south west) $);
    \endscope
  \end{pgfonlayer}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tablegrid}[1]{Optional settings}
%    \begin{macrocode}
\def\tikzdna@tablegrid{%
  \@ifnextchar{*}%
  {\tikzdna@tablegrid@{row\row.high end}}%
  {\tikzdna@tablegrid@{all rows.north east}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tablegrid@@}[2]{Optional settings}{End point}
%    \begin{macrocode}
\def\tikzdna@tablegrid@#1{%
  \@ifnextchar{[}%]
  {\tikzdna@tablegrid@@{#1}}%
  {\tikzdna@tablegrid@@{#1}[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tablegrid@@}[2]{Optional settings}{End point}
%    \begin{macrocode}
\def\tikzdna@tablegrid@@#1[#2]{%
  \begin{pgfonlayer}{background}
    \scope[xstep={\dnawidth/2.},ystep={\dnaheight/2.},dna/table/grid,#2]
    \foreach \row in {1,...,\nrows} {%
      \draw {[shift={(row\row.low start)}]
        let \p1 = (#1) in (0,0) grid (\x1,1)};
    }%
    \endscope
  \end{pgfonlayer}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tableheader}
%   [3]{Optional Settings}{Text title}{Diagram title}
%    \begin{macrocode}
\def\tikzdna@tableheader{%
  \@ifnextchar[%]
  {\tikzdna@tableheader@}%
  {\tikzdna@tableheader@@{}[]}%
}
\def\tikzdna@tableheader@[#1]{%
  \@ifnextchar[%]
  {\tikzdna@tableheader@@{#1}}%
  {\tikzdna@tableheader@@{#1}[]}%
}
\def\tikzdna@tableheader@@#1[#2]#3{%
  \@ifnextchar[%]
  {\tikzdna@tableheader@@@{#1}{#2}{#3}}%
  {\tikzdna@tableheader@@@{#1}{#2}{#3}[]}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tableheader}
%   [5]{Optional settings}{Optional label@header Settings}{Label title}{Optional Diagram title settings}{Diagram title}
%    \begin{macrocode}
\def\tikzdna@tableheader@@@#1#2#3[#4]#5{%
  \path
  let
  \p1 = (label@header),
  \p2 = (all labels.east),
  \p3 = (all labels.west)
  in
  (\x2,\y1) -- node [pos=0,anchor=base east,dna/table/header,dna/table/label header,#1,#2]
  (label header)   {\ignorespaces #3\unskip\strut} (\x3,\y1)
  ;
  \path
  let
  \p4 = (diagram@header),
  \p5 = (all rows.west),
  \p6 = (all rows.east)
  in
  (\x5,\y4) -- node [pos=0,anchor=base west,dna/table/header,dna/table/row header,#1,#4]
  (row header) {\ignorespaces #5\unskip\strut} (\x6,\y4)
  ;
  \tikzdna@tableheadtrue
}
\newif\iftikzdna@tablehead
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@tablerules}[1]{Optional Settings}
%    \begin{macrocode}
\newcommand*\tikzdna@tablerules[1][]{%
  \begin{scope}[#1]
    \coordinate (NW) at (current bounding box.north west);
    \coordinate (SE) at (current bounding box.south east);
    %
    \draw [dna/table/rules]
    let
    \p1 = (NW),
    \p2 = (SE),
    \p3 = (@last row),
    \p4 = (0,\rowdist)
    in
    ($ (\x1-\tabcolsep,\y3) - (0,.5*\y4) $) --
    ($ (\x2+\tabcolsep,\y3) - (0,.5*\y4) $)
    \iftikzdna@tablehead
    (\x1-\tabcolsep,2.5*\y4) -- (\x2+\tabcolsep,2.5*\y4)
    \fi
    ;
    \draw
    \iftikzdna@tablehead [dna/table/midrules] \else [dna/table/rules] \fi
    let
    \p1 = (NW),
    \p2 = (SE)
    in
    (\x1-\tabcolsep,\rowdist) -- (\x2+\tabcolsep,\rowdist)
    ;
  \end{scope}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@horlines}[2]{Optional Settings}{Row numbers}
%    \begin{macrocode}
\newcommand*\tikzdna@horlines[2][]{%
  \begingroup
  \def\list{#2}%
  \ifx\list\empty
  \def\list{1,2,...,\nrows}%
  \fi
  \foreach \row in \list {%
    \draw [dna/table/lines,#1] let
    \p1 = (all rows.south east),
    \p2 = (0,\rowdist)
    in
    ($ (0,\y2) -  (0,\row * \y2) $) -- +(\x1,0);
  }%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@vertlines}[2]{Optional Settings}{Column numbers}
%    \begin{macrocode}
\newcommand*\tikzdna@vertlines[2][]{%
  \begingroup
  \def\list{#2}%
  \ifx\list\empty
  \def\list{0,1,...,\twidth}%
  \fi
  \draw [dna/table/lines,#1] let
  \p1 = ($ (all rows.south east) - (0,2) $)
  in
  \foreach \clk in \list {
    (\clk,+1.5) -- +(0,\y1)
  }
  ;
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Shapes}
%
% Create a shape for the whole diagram.
%    \begin{macrocode}
\pgfdeclareshape{tikzdna@shape}{%
  \savedanchor\northeast{\tikzdna@northeast}%
  \savedanchor\startpoint{\tikzdna@startpoint}%
  \savedanchor\endpoint{\tikzdna@endpoint}%
  \anchor{center}{\pgfpointorigin}%
  \anchor{start}{\startpoint}%
  \anchor{end}{\endpoint}%
  %
  \anchor{origin}{\northeast \pgf@x=-\pgf@x \pgf@y=-\pgf@y }%
  \anchor{east}{\northeast \pgf@y=0pt }%
  \anchor{west}{\northeast \pgf@y=0pt \pgf@x=-\pgf@x }%
  \anchor{north}{\northeast \pgf@x=0pt }%
  \anchor{north west}{\northeast \pgf@x=-\pgf@x }%
  \anchor{north east}{\northeast}
  \anchor{high mid}{\northeast \pgf@x=0pt }%
  \anchor{high start}{\northeast \pgf@x=-\pgf@x }%
  \anchor{high end}{\northeast}
  \anchor{south}{\northeast \pgf@x=0pt \pgf@y=-\pgf@y }%
  \anchor{south west}{\northeast \pgf@x=-\pgf@x \pgf@y=-\pgf@y }%
  \anchor{south east}{\northeast \pgf@y=-\pgf@y }%
  \anchor{low mid}{\northeast \pgf@x=0pt \pgf@y=-\pgf@y }%
  \anchor{low start}{\northeast \pgf@x=-\pgf@x \pgf@y=-\pgf@y }%
  \anchor{low end}{\northeast \pgf@y=-\pgf@y }%
  \anchor{mid}{\pgfpointorigin}%
  \anchor{mid east}{\northeast \pgf@y=0pt }%
  \anchor{mid west}{\northeast \pgf@y=0pt \pgf@x=-\pgf@x }%
  \anchor{mid end}{\northeast \pgf@y=0pt }%
  \anchor{mid start}{\northeast \pgf@y=0pt \pgf@x=-\pgf@x }%
  \anchor{base}{\northeast \pgf@x=0pt \pgf@y=-\pgf@y }%
  \anchor{base west}{\northeast \pgf@x=-\pgf@x \pgf@y=-\pgf@y }%
  \anchor{base east}{\northeast \pgf@y=-\pgf@y }%
  \anchorborder{%
    \@tempdima=\pgf@x
    \@tempdimb=\pgf@y
    \pgfpointborderrectangle{\pgfpoint{\@tempdima}{\@tempdimb}}{\northeast}%
  }%
}
%    \end{macrocode}
%
% By default use the old node centers for backwards compatibility.
%    \begin{macrocode}
\gdef\tikzdna@oldnodecenter@{}%
\tikzset{dna/old@node@center/.code={\xdef\tikzdna@oldnodecenter@{%
      ++($ (0,0) - #1 $)
      [dna/no@old@node@center]}}%
}%
\tikzset{dna/no@old@node@center/.code={\gdef\tikzdna@oldnodecenter@{}}}%

\def\tikzdna@oldnodecenter#1{%
  [dna/old@node@center={#1}]
  ++#1
}

%    \end{macrocode}
%
% \subsection{Other macros}
%
% \begin{macro}{\tikzdna@iflower}
%   Pick the first or second of the awaiting arguments based on whether |#1|
%   is an alphabetic character.
%   \mybreak Usage: \cs{tikzdna@iflower} \meta{character}
%    \begin{macrocode}
\def\tikzdna@iflower#1{%
  \begingroup
  \edef\@tempa{`#1}%
  \ifnum\@tempa=\lccode\@tempa
  \endgroup
  \expandafter
  \@firstoftwo
  \else
  \endgroup
  \expandafter
  \@secondoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@internaldefs}[3]{Character}{Character}{Character}
%    \begin{macrocode}
\def\tikzdna@internaldefs{%
  \let\draw\relax
  \let\path\relax
  \let\p\relax
  \let\x\relax
  \let\y\relax
  \let\n\relax
  \let\tikzdna@oldnodecenter\relax
  \let\tikzdna@oldnodecenter@\relax
  \def\width{####1*\noexpand\dnawidth}%
  \def\fwidth{\noexpand\dnawidth}%
  \def\height{\noexpand\dnaheight}%
  \def\slope{\noexpand\dnaslope}%
  \def\zslope{\noexpand\dnazslope}%
  \def\dslope{\noexpand\dnadslope}%
  \def\gslope{0}%
  \def\style{dna/every char,dna/####3}%
  \def\bgstyle{draw=none,dna/every bg,dna/####3/background}%
  \def\nstyle{dna/every char,dna/####4}%
  \def\newdraw{\tikzdna@newdraw}%
  \def\newdrawns{\tikzdna@newdraw@nosave}%
  \def\code##1{ [/utils/exec={\unexpanded{##1}}] }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnasetslope}[1]{Slope value}
%    \begin{macrocode}
\def\tikzdnasetslope#1{%
  \pgfmathparse{min(1.0,{max(0.0,#1)})}%
  \let\tikzdna@slope\pgfmathresult
  \edef\dnaslope{\tikzdna@slope*\noexpand\dnawidth}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnasetdslope}[1]{Slope value}
%    \begin{macrocode}
\def\tikzdnasetdslope#1{%
  \pgfmathparse{min(1.0,{max(0.0,#1)})}%
  \let\tikzdna@dslope\pgfmathresult
  \edef\dnadslope{\tikzdna@dslope*\noexpand\dnawidth}%
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\tikzdnasetzslope}[1]{Slope value}
%    \begin{macrocode}
\def\tikzdnasetzslope#1{%
  \pgfmathparse{min(1.0,{max(0.0,#1)})}%
  \let\tikzdna@zslope\pgfmathresult
  \edef\dnazslope{\tikzdna@zslope*\noexpand\dnawidth}%
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\tikzdnasetslope{0.10}%
\tikzdnasetdslope{0.20}%
\tikzdnasetzslope{0.05}%
%    \end{macrocode}
%
% \subsection{Sequence character definition macros}
%
% \begin{macro}{\tikzdnachar}
%   Register a new sequence character. The character will be uppercased.
%   \mybreak Usage: \cs{tikzdnachar} \meta{character}
%    \begin{macrocode}
\def\tikzdnachar#1{%
  \uppercase{%
    \tikzdna@addchar{#1}%
    \tikzdnachar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@addchar}[1]{Character}
%    \begin{macrocode}
\def\tikzdna@addchar#1{%
  \tikzdna@ifcharexists{#1}{%
    \edef\tikzdna@chars{\tikzdna@chars,#1}%
  }{}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnachar@}[3]{Character}{Start position}{Character
%   drawing code}
%    \begin{macrocode}
\def\tikzdnachar@#1#2#3{%
  \tikzdna@nameedef{@}{#1}{}{#2 coordinate (dna/start) #3}%
  \tikzdnadef{{#1}{#1}}{#3}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnause}[1]{Character(s)}
%    \begin{macrocode}
\def\tikzdnause#1#2{%
  \@nameuse{\tikzdna@prefix#1}{#2}{##2}{##3}{##4}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnadef}[1]{One till three characters}
%    \begin{macrocode}
\def\tikzdnadef#1{%
  \tikzdnadef@#1\empty\empty\relax
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnadef@}[3]{First character}{Second character or
%   empty}{Definition code}
%    \begin{macrocode}
\def\tikzdnadef@#1#2#3\relax#4{%
  \ifx\empty#2\empty
  \tikzdna@nameedef{}{#1}{}{#4}%
  \else
  \tikzdna@nameedef{#1}{#2}{#3}{#4}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnacpy}[2]{New Character(s)}{Source Character(s)}
%    \begin{macrocode}
\def\tikzdnacpy#1#2{%
  \begingroup
  \edef\tikzdnacpy@a{#1}%
  \edef\tikzdnacpy@b{#2}%
  \ifx\tikzdnacpy@a\tikzdnacpy@b
  \endgroup
  % \message{^^J Copy macro '#2' to '#1' skipped.^^J}%
  \else
  \endgroup
  \@ifundefined{\tikzdna@pfxtr#2\empty\empty\empty}%
  {\ifnum\tikzdna@debug>0\relax
    \message{^^J Copy macro '#2' to '#1' failed.^^J}\fi}%
  {\ifnum\tikzdna@debug>0\relax
    \message{^^J Copy macro '#2' to '#1'.^^J}\fi
    \expandafter\let
    \csname\tikzdna@pfxtr#1\empty\empty\empty\expandafter\endcsname
    \csname\tikzdna@pfxtr#2\empty\empty\empty\endcsname
  }%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdnalet}[2]{Original characters}{New characters}
%    \begin{macrocode}
\def\tikzdnalet#1#2{%
  \tikzdna@namelet{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@chars}[1]{Comma to gobble}
%   Initial definition of character list. Will gobble the separation comma in
%   front of the first character which is added to the list.
%    \begin{macrocode}
\def\tikzdna@chars#1{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@ifcharexists}[1]{Character to check if in list}
%    \begin{macrocode}
\def\tikzdna@ifcharexists#1{%
  \def\tikzdna@ifcharexists@##1,#1,##2\relax{%
    \ifx\relax##2\relax%
    \expandafter\@firstoftwo
    \else
    \expandafter\@secondoftwo
    \fi
  }%
  \expandafter\tikzdna@ifcharexists@
  \expandafter,\tikzdna@chars,#1,\relax%
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\@namedef{\tikzdna@prefix @@}#1#2#3#4{ coordinate (dna/start)}%
%    \end{macrocode}
%
% \begin{macro}{\tikzdnaecopy}[2]{New character}{Original character}
%    \begin{macrocode}
\def\tikzdnaecopy#1#2{%
  \@namedef{tikzdna@alias@#1}{#2}%
  \tikzdna@addchar{#1}%
  \expandafter\let
  \csname tikzdna@triple@#1\expandafter\endcsname
  \csname tikzdna@triple@#2\endcsname
  \expandafter\let
  \csname tikzdna@nocombine@#1\expandafter\endcsname
  \csname tikzdna@nocombine@#2\endcsname
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@setref}[2]{Reference Name}{Shift Offset}
%    \begin{macrocode}
\def\tikzdna@setref#1#2{%
  coordinate (#1) coordinate (#1) at ([shift={(#2)}]#1)
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{NewDraw macros}
%
% \begin{macro}{\tikzdna@newdraw}
%    \begin{macrocode}
\def\tikzdna@newdraw{%
  node [dna/save] (dna@save) {};%
  \draw [dna/restore] (dna@save) ++(0,0)
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@newdraw@nosave}
%    \begin{macrocode}
\def\tikzdna@newdraw@nosave{%
  node [dna/coord] (dna@save) {};%
  \draw [dna/nooptions] (dna@save) ++(0,0)
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tikzdna@baseline}
%    \begin{macrocode}
\def\tikzdna@baseline{%
  node [dna/save] (dna@save) {};%
  \draw [dna/restore] let \p1 = (dna@save) in (\x1,0) ++(0,0)
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Definition of sequence characters}
%
% Pre-define list of dna characters to have it in a sorted fashion.
%    \begin{macrocode}
\def\tikzdna@chars{H,L,Z,X,M,D,U,T,C}%
%    \end{macrocode}
%
% \subsubsection{Character `S'}
% This character is now implemented as modifier to avoid hassle with triple
% character transitions.
%    \begin{macrocode}
\tikzdna@defcode{S}{%
  \pgfmathparse{\tikzdnawidth + \tikzdna@num}%
  \global\let\tikzdnawidth\pgfmathresult
  \tikzdna@output@Eaddcode{%
    coordinate (dna@ref)  at ($ (dna@ref)  + (\tikzdna@num,0) $)
    coordinate (dna@refa) at ($ (dna@refa) + (\tikzdna@num,0) $)
    coordinate (dna@refb) at ($ (dna@refb) + (\tikzdna@num,0) $)
    ++(\tikzdna@num,0)
  }%
  \tikzdna@parser
}

\tikzdna@defcode{s}{%
  \pgfmathparse{\tikzdnawidth + \tikzdna@num/2}%
  \global\let\tikzdnawidth\pgfmathresult
  \tikzdna@output@Eaddcode{%
    coordinate (dna@ref)  at ($ (dna@ref)  + (\tikzdna@num/2,0) $)
    coordinate (dna@refa) at ($ (dna@refa) + (\tikzdna@num/2,0) $)
    coordinate (dna@refb) at ($ (dna@refb) + (\tikzdna@num/2,0) $)
    ++(\tikzdna@num/2,0)
  }%
  \tikzdna@parser
}
%    \end{macrocode}
%
% \subsubsection{Character `G'}
%    \begin{macrocode}
\tikzdna@defcode{G}{%
  \tikzdna@output@addcode{%
    \tikzdna@glitch
  }%
  \tikzdna@parser
}

\tikzdna@defcode{g}{%
  \tikzdna@output@addcode{%
    \tikzdna@glitch
  }%
  \tikzdna@parser
}

\def\tikzdna@glitch{%
  {[dna/every char,dna/g] let \p1 = +(0,0) in (\x1,0) -- (\x1,\dnaheight)
    coordinate (dna@dstart) at (\x1,\dnaheight/2) (\x1,\y1)
  }%
}
%    \end{macrocode}
%
% \subsubsection{Character `H'}
%    \begin{macrocode}
\tikzdnachar{H}{++(0,\height)}{[\style] -- ++(#1,0)}

\tikzdnadef{HH}{
  -- ++(#1,0)
}

\tikzdnadef{LH}{
  --  +(\slope, \height)
  -- ++(#1, \height)
}

\tikzdnadef{ZH}{
  \newdraw [\style]
  -- ++(\zslope,+\height/2.)
  -- ++($ (#1,0) - (\zslope,0) $)
}

\tikzdnadef{DH}{
  \tikzdna@oldnodecenter@%
  \newdraw [\style]
  --  +(\dslope/2.,\height/2.)
  --   ($ (dna@ref) + (#1,\height/2) $)
}

%    \end{macrocode}
%
% \subsubsection{Character `L'}
%    \begin{macrocode}
\tikzdnadef{DL}{
  \tikzdna@oldnodecenter@
  \newdraw [\style]
  --  +(\dslope/2.,-\height/2.)
  --   ($ (dna@ref) + (#1,-\height/2) $)
}

%    \end{macrocode}
%
% \subsubsection{Character `'}
%    \begin{macrocode}

\tikzdnachar{L}{++(0,0)}{[\style] -- ++(#1,0)}

\tikzdnachar{Z}{++(0,\height/2.)}{%
  \newdraw [\style]
  -- ++(#1,0)
}

\tikzdnachar{D}{++(0,\height/2.)}{
  node [dna/save] (dna@save) {}; \path [\bgstyle] (dna@save) ++(0,0)
  -- +(#1,0)
  -- +($ (#1,0) + 0.5*(\dslope,\height) $)
  -- +(#1,\height)
  -- +(0,\height)
  -- cycle;
  \draw [dna/restore,\style] (dna@save) ++(0,0)
  node [dna/save] (dna@dstart) at +(-\dslope/2.,\height/2.0) {}
  --  +(#1,0) ++(0,+\height)
  -- ++(#1,0) ++(0,-\height)
}

\def\tikzdna@triple@D{}%
\def\tikzdna@triple@D@edge@{}%
\def\tikzdna@nocombine@D@edge@{}%
\def\tikzdna@alias@D@edge@{D}%
%    \end{macrocode}
%
% \begin{macro}{\tikzdna@trans@D@fill}[2]{Original width}{Width to subtract}
%    \begin{macrocode}
\def\tikzdna@trans@D@fill#1#2{%
  node [dna/save] (dna@save) {}; \path [\bgstyle] (dna@save) ++(0,0)
  -- +(0.5*\dslope,-0.5*\height)
  -- ++($ (#1,-0.5*\height) - (#2,0) $)
  -- +(0.5*\dslope,0.5*\height)
  -- +(0,\height)
  -- ++($ (#2,\height) - (#1,0) + (0.5*\dslope,0) $)
  -- cycle;
  \draw [dna/restore,\style] (dna@save) ++(0,0)
  node [dna/save] (dna@dstart) {}
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\tikzdnadef{LL}{
  -- ++(#1,0)
}

\tikzdnadef{HL}{
  -- ++(\slope,-\height)
  \tikzdnause{HH}{#1-\slope}
}

\tikzdnadef{LZ}{
  \newdraw [\style]
  -- ++(\zslope,+\height/2.)
  -- ++($ (#1,0) - (\zslope,0) $)
}

\tikzdnadef{HZ}{%
  \newdraw [\style]
  -- ++(\zslope,-\height/2.)
  -- ++($ (#1,0) - (\zslope,0) $)
}

\tikzdnadef{ZL}{%
  \newdraw [\style]
  -- ++(\zslope,-\height/2.)
  -- ++($ (#1,0) - (\zslope,0) $)
}

\tikzdnadef{DZ}{
  \tikzdna@oldnodecenter@
  \newdraw [\style]
  -- ($ (dna@ref) + (#1,0) $)
}

\def\tikzdna@chard#1{%
  \newdraw [\style,preaction={\bgstyle}]
  coordinate (dna@dstart)
  -- +(\dslope/2,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(\dslope/2,-\height/2)
  -- +(0,-\height)
  --  ($ (dna@dstart) + (\dslope/2,-\height/2) $)
  --  (dna@dstart)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  ++(\dslope/2,0)
  coordinate (dna@dend)
  \tikzdna@oldnodecenter{%
    (-\dslope/2,-\height/2)
  }%
  \newdraw [dna/every char]
}

\def\tikzdna@chard@#1{%
  \newdraw [\bgstyle]
  -- +(\dslope/2,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(0,-\height)%
  --  ($ (dna@save) + (\dslope/2,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  coordinate (dna@dstart)
  -- +(\dslope/2,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  +(0,-\height)%
  --  ($ (dna@save) + (\dslope/2,-\height/2) $)
  --  (dna@save)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  \tikzdna@setref{dna@dend}{\dslope/2,0}
  \tikzdna@oldnodecenter{%
    (0,-\height/2)
  }%
  \newdraw [dna/every char]
}

\def\tikzdna@@chard#1{%
  ++(0,\height/2)
  \newdraw [\bgstyle]
  -- +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(\dslope/2,-\height/2)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  +(0,0)
  coordinate (dna/start)
  +(-\dslope/2,0)
  coordinate (dna@dstart)
  +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(\dslope/2,-\height/2)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  ++(\dslope/2,0)
  coordinate (dna@dend)
  \tikzdna@oldnodecenter{%
    (-\dslope/2,-\height/2)
  }%
  \newdraw [dna/every char]
}

\def\tikzdna@@chard@#1{%
  ++(0,\height/2)
  \newdraw [\bgstyle]
  -- +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  +(0,0)
  coordinate (dna/start)
  coordinate (dna@ref)
  \tikzdna@setref{dna@dstart}{-\dslope/2,0}
  +(0,\height/2)
  -- +(#1,\height/2)
  +(#1,-\height/2)
  --  ($ (dna@save) + (0,-\height/2) $)
  ++(#1,\height/2)
  coordinate (dna@ref)
  \tikzdna@setref{dna@dend}{\dslope/2,0}
  \tikzdna@oldnodecenter{%
    (0,-\height/2)
  }%
  \newdraw [dna/every char]
}

\def\tikzdna@dchardu#1{%
  \tikzdna@oldnodecenter@
  \newdraw [\bgstyle]
  -- +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(\dslope/2,-\height/2)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(\dslope/2,-\height/2)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  ++(\dslope/2,0)
  coordinate (dna@dend)
  \tikzdna@oldnodecenter{%
    (-\dslope/2,-\height/2)
  }%
  \newdraw [dna/every char]
}

\def\tikzdna@uchardd#1{%
  \tikzdna@oldnodecenter@
  \newdraw [\bgstyle]
  -- +(\dslope/2,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(0,-\height)
  --  ($ (dna@save) + (\dslope/2,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  coordinate (dna@dstart)
  -- +(\dslope/2,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  +(0,-\height)
  --  ($ (dna@save) + (\dslope/2,-\height/2) $)
  --  (dna@save)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  coordinate [shift={(\dslope/2,0)}](dna@dend)
  \tikzdna@oldnodecenter{%
    ($ (0,0) - (0,\height/2) $)
  }%
  \newdraw [dna/every char]
}

\tikzdnadef{DD}{%
  \tikzdna@dchardu{#1}%
}

\tikzdnadef{UU}{%
  \tikzdna@dchardu{#1}%
}

\def\tikzdna@dchard@#1{%
  \tikzdna@oldnodecenter@
  \newdraw [\bgstyle]
  -- +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  -- +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  --  (dna@save)
  \newdraw [\style]
  +(0,\height/2)
  --  ($ (dna@ref) + (#1,\height/2) $)
  +(0,-\height)
  --  ($ (dna@save) + (0,-\height/2) $)
  ($ (dna@ref) + (#1,0) $)
  coordinate (dna@ref)
  \tikzdna@setref{dna@dend}{\dslope/2,0}
  \tikzdna@oldnodecenter{%
    (0,-\height/2)
  }%
  \newdraw [dna/every char]
}

\tikzdnadef{DD@}{
  \tikzdna@dchard@{#1}%
}

\tikzdnacpy{DDD}{DD@}
\tikzdnacpy{UUU}{DDD}

\tikzdnadef{{D@edge@}{D@edge@}}{%
  \tikzdna@oldnodecenter@
  \tikzdna@chard{#1}%
}%

\tikzdnadef{@{D@edge@}}{%
  \tikzdna@@chard@{#1}%
}%

\tikzdnadef{@{D@edge@}@}{%
  \tikzdna@@chard@{#1}%
}%

\tikzdnadef{@{D@edge@}D}{%
  \tikzdna@@chard{#1}%
}

\tikzdnadef{D{D@edge@}}{%
  \tikzdna@dchardu{#1}%
}

\tikzdnadef{U{U@edge@}}{%
  \tikzdna@dchardu{#1}%
}

\tikzdnadef{U{D@edge@}}{%
  \tikzdna@oldnodecenter@
  \tikzdna@chard{#1}%
}

\tikzdnadef{U{D@edge@}@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}

\tikzdnadef{D{U@edge@}}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard{#1}%
}

\tikzdnadef{D{U@edge@}@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}

\tikzdnadef{D{D@edge@}@}{%
  \tikzdna@dchard@{#1}%
}%

\tikzdnadef{U{U@edge@}@}{%
  \tikzdna@dchard@{#1}%
}%

\tikzdnadef{{D@edge@}{D@edge@}@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}%

\tikzdnadef{@{D@edge@}}{%
  \tikzdna@@chard{#1}%
}%

\tikzdnadef{{D@edge@}D}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard{#1}%
}%

\tikzdnadef{{D@edge@}D@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}%

\tikzdnadef{ZDZ}{
  coordinate (dna@ref)
  \tikzdna@chard{#1}
}
\tikzdnacpy{ZDX}{ZDZ}
\tikzdnacpy{XDX}{ZDZ}
\tikzdnacpy{XDZ}{ZDZ}

\tikzdnadef{ZDD}{
  coordinate (dna@ref)
  \tikzdna@chard@{#1}
}

\tikzdnadef{ZDU}{
  coordinate (dna@ref)
  \tikzdna@chard{#1}
}

\tikzdnacpy{ZUD}{ZDU}
\tikzdnacpy{ZUU}{ZDD}

\tikzdnadef{ZD}{
  coordinate (dna@ref)
  \tikzdna@chard{#1}
}

\tikzdnadef{@DD}{%
  \tikzdna@@chard@{#1}%
}

\tikzdnadef{ZD@}{%
  coordinate (dna@ref)
  \tikzdna@chard@{#1}%
}

\tikzdnadef{HD@}{%
  \tikzdna@setref{dna@ref}{0,-\height/2}
  -- ++(\dslope/2, -\height/2)
  \tikzdna@chard@{#1}%
}

\tikzdnadef{TD@}{%
  \tikzdna@setref{dna@ref}{0,-\height/2 * \value{tikzdnatrans}}
  -- ++(\dslope/2, -\height/2 * \value{tikzdnatrans})
  \tikzdna@chard@{#1}%
}

\tikzdnadef{TD}{%
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  \tikzdna@setref{dna@ref}{0,\height/2 * \value{tikzdnatrans}}
  -- ++(\dslope/2, \height/2 * \value{tikzdnatrans})
  \tikzdna@chard{#1}%
}

\tikzdnadef{TDD}{%
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  \tikzdna@setref{dna@ref}{0,\height/2 * \value{tikzdnatrans}}
  -- ++(\dslope/2, \height/2 * \value{tikzdnatrans})
  \tikzdna@chard@{#1}%
}

\tikzdnadef{TUD}{%
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  \tikzdna@setref{dna@ref}{0,\height/2 * \value{tikzdnatrans}}
  -- ++(\dslope/2, \height/2 * \value{tikzdnatrans})
  \tikzdna@chard{#1}%
}

\tikzdnacpy{TDU}{TUD}
\tikzdnacpy{TUU}{TDD}

\tikzdnadef{LD@}{%
  \tikzdna@setref{dna@ref}{0,\height/2}
  -- ++(\dslope/2, \height/2)
  \tikzdna@chard@{#1}%
}

\tikzdnadef{@D}{%
  \tikzdna@@chard@{#1}%
}

\tikzdnadef{@D@}{%
  \tikzdna@@chard@{#1}%
}

\tikzdnacpy{H{D@edge@}@}{HD@}
\tikzdnacpy{L{D@edge@}@}{LD@}
\tikzdnacpy{Z{D@edge@}@}{ZD@}
\tikzdnacpy{T{D@edge@}@}{TD@}

\tikzdnadef{@DZ}{%
  \tikzdna@@chard{#1}%
}
\tikzdnadef{@DH}{%
  \tikzdna@@chard{#1}%
}
\tikzdnadef{@DL}{%
  \tikzdna@@chard{#1}%
}
\tikzdnadef{@DT}{%
  \tikzdna@@chard{#1}%
}

\tikzdnadef{LD}{
  \tikzdna@setref{dna@ref}{0,\height/2}
  -- ++(\dslope/2, \height/2)
  \tikzdna@chard{#1}%
}

\tikzdnadef{LDD}{
  \tikzdna@setref{dna@ref}{0,\height/2}
  -- ++(\dslope/2, \height/2)
  \tikzdna@chard@{#1}
}

\tikzdnadef{LDU}{
  \tikzdna@setref{dna@ref}{0,\height/2}
  -- ++(\dslope/2, \height/2)
  \tikzdna@chard{#1}
}

\tikzdnacpy{LUD}{LDU}
\tikzdnacpy{LUU}{LDD}

\tikzdnadef{HD}{
  \tikzdna@setref{dna@ref}{0,-\height/2}
  -- ++(\dslope/2, -\height/2)
  \tikzdna@chard{#1}
}

\tikzdnadef{HDD}{
  \tikzdna@setref{dna@ref}{0,-\height/2}
  -- ++(\dslope/2, -\height/2)
  \tikzdna@chard@{#1}
}

\tikzdnadef{HDU}{
  \tikzdna@setref{dna@ref}{0,-\height/2}
  -- ++(\dslope/2, -\height/2)
  \tikzdna@chard{#1}
}
\tikzdnacpy{HUD}{HDU}
\tikzdnacpy{HUU}{HDD}

%    \end{macrocode}
%
% \subsection{Character `M'}
%    \begin{macrocode}
\tikzdnaecopy{M}{Z}
\tikzdnachar{M}{++(0,\height/2.)}{
  \newdraw [\style]
  -- ++(#1,0)
  \newdraw [\style/base]
}

\tikzdnadef{ZM}{
  \newdraw [\style]
  -- ++(#1,0)
  \newdraw [\style/base]
}

\tikzdnadef{LM}{
  \newdraw [\style/base]
  -- ++($ (1/8,0) + (0,\height/2) $)
  \newdraw [\style]
  -- ++($ (-1/8,0) + (#1,0) $)
  \newdraw [\style/base]
}

\tikzdnadef{HM}{
  \newdraw [\style/base]
  -- ++($ (1/8,0) + (0,-1*\height/2) $)
  \newdraw [\style]
  -- ++($ (-1/8,0) + (#1,0) $)
  \newdraw [\style/base]
}

\tikzdnadef{DM}{
  \tikzdna@oldnodecenter@%
  \newdraw [\style]
  -- ($ (dna@ref) + (#1,0) $)
  \newdraw [\style/base]
}

%    \end{macrocode}
%
% \subsubsection{Character `T'}
%    \begin{macrocode}
\newcounter{tikzdnatrans}
\newcounter{tikzdnatranspos}

\tikzdnachar{T}{++(0,0)}{
  -- ++(#1,0)
}
\def\tikzdna@nocombine@T{}%

\tikzdnadef{HT}{%
  {[\style]
    \code{\setcounter{tikzdnatrans}{-1}}
    -- ++(\slope,\value{tikzdnatrans}*\height) -- ++($ (#1,0) - (\slope,0) $)
  }
}

\tikzdnadef{LT}{%
  {[\style]
    \code{\setcounter{tikzdnatrans}{+1}}
    -- ++(\slope,\value{tikzdnatrans}*\height) -- ++($ (#1,0) - (\slope,0) $)
  }
}

\tikzdnadef{TL}{%
  \code{\setcounter{tikzdnatranspos}{\value{tikzdnatrans}}%
    \addtocounter{tikzdnatranspos}{+1}}
  -- ++(\slope, -0.5*\value{tikzdnatranspos}*\height) -- ++($ (#1,0) - (\slope,0) $)
}

\tikzdnadef{TH}{%
  \code{\setcounter{tikzdnatranspos}{\value{tikzdnatrans}}%
    \addtocounter{tikzdnatranspos}{-1}}
  -- ++(\slope, -0.5*\value{tikzdnatranspos}*\height) -- ++($ (#1,0) - (\slope,0) $)
}

\tikzdnadef{TZ}{%
  \newdraw [\style]
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  -- ++(\zslope,\value{tikzdnatrans}*\height/2.)
  -- ++($ (#1,0) - (\zslope,0) $)
}

\tikzdnadef{ZT}{%
  \newdraw [dna/every char] {[\style]
    \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
    -- ++(\zslope,\value{tikzdnatrans}*\height/2.)
    -- ++($ (#1,0) - (\zslope,0) $)
  }
}

\tikzdnadef{TT}{%
  {[\style]
    \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
    -- ++(\slope,\value{tikzdnatrans}*\height)
    -- ++($ (#1,0) - (\slope,0) $)
  }
}

\tikzdnadef{DT}{
  \code{\setcounter{tikzdnatrans}{-1}}
  \tikzdna@oldnodecenter@%
  \newdraw [dna/every char] {[\style]
    --  +(\dslope/2.,-\height/2)
    --   ($ (dna@ref) + (#1,-\height/2) $)
  }
}

\tikzdnadef{TM}{%
  \newdraw [\style/base]
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  -- ++($ (1/8,0) + (0,\value{tikzdnatrans}*\height/2) $)
  \newdraw [\style]
  -- ++($ (-1/8,0) + (#1,0) $)
  \newdraw [\style/base]
}
%    \end{macrocode}
%
% \subsubsection{Character `C'}
%    \begin{macrocode}
\tikzdnaecopy{C}{T}
%    \end{macrocode}
%
% \subsubsection{Character `U'}
%    \begin{macrocode}
\tikzdnaecopy{U}{D}

\def\tikzdna@triple@U@edge@{}%
\def\tikzdna@nocombine@U@edge@{}%
\def\tikzdna@alias@U@edge@{D@edge@}%

\tikzdnacpy{UU@}{DD@}%

\tikzdnadef{UDU}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard{#1}%
}
\tikzdnacpy{DUD}{UDU}%

\tikzdnadef{UDD}{%
  \tikzdna@uchardd{#1}%
}

\tikzdnacpy{{D@edge@}DD}{UDD}
\tikzdnacpy{{U@edge@}UU}{{D@edge@}DD}

\tikzdnadef{H{D@edge@}}{
  \tikzdna@setref{dna@ref}{0,-\height/2}
  -- ++(\dslope/2, -\height/2)
  \tikzdna@chard{#1}%
}

\tikzdnadef{L{D@edge@}}{
  \tikzdna@setref{dna@ref}{0,\height/2}
  -- ++(\dslope/2, \height/2)
  \tikzdna@chard{#1}%
}

\tikzdnadef{Z{D@edge@}}{
  coordinate (dna@ref)
  \tikzdna@chard{#1}%
}

\tikzdnadef{T{D@edge@}}{
  \code{\setcounter{tikzdnatrans}{-\value{tikzdnatrans}}}
  \tikzdna@setref{dna@ref}{0,\height/2 * \value{tikzdnatrans}}
  -- ++(\dslope/2, \height/2 * \value{tikzdnatrans})
  \tikzdna@chard{#1}%
}

\tikzdnadef{{D@edge@}DU}{
  \tikzdna@oldnodecenter@
  \tikzdna@chard{#1}
}
\tikzdnacpy{{U@edge@}UD}{{D@edge@}DU}

\tikzdnadef{DDU}{%
  \tikzdna@dchardu{#1}
}

\tikzdnacpy{DUU}{UDD}%
\tikzdnacpy{UUD}{DDU}%

\tikzdnadef{@UU}{%
  \tikzdna@@chard@{#1}%
}

\tikzdnadef{@UD}{%
  \tikzdna@@chard{#1}%
}

\tikzdnadef{@DU}{%
  \tikzdna@@chard{#1}%
}

\tikzdnadef{UD}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard{#1}%
}

\tikzdnadef{DU}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard{#1}%
}

\tikzdnadef{UD@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}

\tikzdnadef{DU@}{%
  \tikzdna@oldnodecenter@%
  \tikzdna@chard@{#1}%
}

%    \end{macrocode}
%
% \subsubsection{Character `X'}
%    \begin{macrocode}
\tikzdnaecopy{X}{Z}
%    \end{macrocode}
%
% Save current list of characters as list of default characters.
%    \begin{macrocode}
\let\tikzdna@chars@default\tikzdna@chars
%    \end{macrocode}
%
% \clearpage
% \subsection{Libraries}
%
%    \begin{macrocode}
\newcommand*\usetikzdnalibrary[2][]{%
  \edef\tikzdna@library@options{#1}%
  \@ifnextchar{[}%]
  {\tikzdna@library{#2}}%
  {\tikzdna@library{#2}[]}%
}
\def\tikzdna@library#1[#2]{%
  \edef\tikzdna@library@date{#2}%
  \tikzdna@library@#1,\relax
}
%    \end{macrocode}
% Load the library as package. The \LaTeX\ core macro \cs{zap@space} is patched
% to a no-op to keep spaces in the option text. Otherwise the option keys may
% not contain spaces.
%    \begin{macrocode}
\def\tikzdna@zap@space#1 \@empty{#1}

\def\tikzdna@library@#1,{%
  \IfFileExists{tikz-dna-#1.sty}%
  { \let\tikzdna@orig@zap@space\zap@space
    \let\zap@space\tikzdna@zap@space
    \RequirePackage
    [\tikzdna@library@options]%
    {tikz-dna-#1}%
    [\tikzdna@library@date]%
    \let\zap@space\tikzdna@orig@zap@space
  }%
  {\PackageError{tikz-dna}%
    {No tikz-dna library `#1' found!}{}%
  }%
  \@ifnextchar\relax{}{\tikzdna@library@}%
}
%    \end{macrocode}
%
% \Finale
%
\endinput
